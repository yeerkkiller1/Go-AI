<html>

<!-- Mirrored from fuego.sourceforge.net/fuego-doc-1.1/smartgame-doc/classSgVectorOf.html by HTTrack Website Copier/3.x [XR&CO'2010], Wed, 25 Apr 2012 18:00:30 GMT -->
<head>
<title>SmartGame Library: SgVectorOf&lt; T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<div class="qindex">
<a class="qindex" href="../main.html">Index</a> &nbsp;
<a class="qindex" href="index.html">Main</a> &nbsp;
<a class="qindex" href="namespaces.html">Namespaces</a> &nbsp;
<a class="qindex" href="classes.html">Classes</a> &nbsp;
<a class="qindex" href="hierarchy.html">Hierarchy</a> &nbsp;
<a class="qindex" href="annotated.html">Annotated</a> &nbsp;
<a class="qindex" href="files.html">Files</a> &nbsp;
<!--
<a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp;>
-->
<a class="qindex" href="functions.html">Compound</a> &nbsp;
<a class="qindex" href="globals.html">Global</a> &nbsp;
<a class="qindex" href="pages.html">Pages</a> &nbsp;
</div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a>  </div>
  <div class="headertitle">
<h1>SgVectorOf&lt; T &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="SgVectorOf" --><!-- doxytag: inherits="SgVector&lt; void * &gt;" -->
<p>Typed vector of pointers to T.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SgVector_8h_source.html">SgVector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SgVectorOf&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classSgVectorOf__inherit__graph.png" border="0" usemap="#SgVectorOf_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="SgVectorOf_3_01T_01_4_inherit__map" id="SgVectorOf_3_01T_01_4_inherit__map">
<area shape="rect" id="node2" href="classSgVector.html" title="SgVector\&lt; void * \&gt;" alt="" coords="5,5,152,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classSgVectorOf-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVectorOf.html#a3137ccc12c5366ccb990a93350d1db75">operator[]</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return const reference to element.  <a href="#a3137ccc12c5366ccb990a93350d1db75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVectorOf.html#af5ac4b3fd17c0d3df5dbb535eece5020">Back</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last element of the vector.  <a href="#af5ac4b3fd17c0d3df5dbb535eece5020"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVectorOf.html#a2e687bc1a090b418a28ec41921ae67af">Contains</a> (const T *element) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVectorOf.html#a28080e1902982c62a1b1681ce221a500">Include</a> (const T *element)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push <code>elt</code> to the back of the vector unless it is already included.  <a href="#a28080e1902982c62a1b1681ce221a500"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVectorOf.html#ac7893f0d0532bcb662d069a86f174cab">Exclude</a> (const T *element)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVectorOf.html#a2cc01d290f43682f180bb81afc3c256c">Exclude</a> (const <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt; &amp;vector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVectorOf.html#a85b09b37995786453410cb1f5bc3e58b">Front</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first element of the vector.  <a href="#a85b09b37995786453410cb1f5bc3e58b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVectorOf.html#a40c9718e827f321f80c62d9065cfaf38">Insert</a> (const T *element)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVectorOf.html#abdcbd46ebf329701ff97315f142db56e">PushFront</a> (const T *element)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVectorOf.html#a9766e2f06df99110cfe2a093aed86779">PushBack</a> (const T *element)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVectorOf.html#ac2747bfdbf87580d10fd41aee9d82c7d">PopFront</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove element[0] of the vector.  <a href="#ac2747bfdbf87580d10fd41aee9d82c7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a574064d880ced8e2bfe6267fb4cc5c3b">operator[]</a> (int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return reference to element.  <a href="#a574064d880ced8e2bfe6267fb4cc5c3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#ab01cd66d227fdaa8ab91db708d22dcbf">operator==</a> (const <a class="el" href="classSgVector.html">SgVector</a>&lt; void * &gt; &amp;rhs) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare whether the contents of two vectors are identical.  <a href="#ab01cd66d227fdaa8ab91db708d22dcbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a5cc61a0421557942a6159f67d9faed32">operator!=</a> (const <a class="el" href="classSgVector.html">SgVector</a> &amp;rhs) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare whether the contents of two vectors are not identical.  <a href="#a5cc61a0421557942a6159f67d9faed32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a40a18e1bd8196a7f922818a453ba429e">BackAndPop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a5ff70a14db39eef24ee4fb9b9630922c">Clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all elements in this vector.  <a href="#a5ff70a14db39eef24ee4fb9b9630922c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#aaed64fdb221f8c2455891607b03e2e1a">Concat</a> (<a class="el" href="classSgVector.html">SgVector</a>&lt; void * &gt; *tail)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push all of <code>*tail</code> to the back of this vector, and clear the <code>*tail</code> vector.  <a href="#aaed64fdb221f8c2455891607b03e2e1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#abc43a6f3a6a438e470a289ef64b4168d">Contains</a> (const void *&amp;elt) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if element is in vector.  <a href="#abc43a6f3a6a438e470a289ef64b4168d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a570f5f72b2aa5ac445b83c64e63f5f11">DeleteAt</a> (int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">delete element at specified index  <a href="#a570f5f72b2aa5ac445b83c64e63f5f11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#aea4b69afb050ab924e3783e2cbc026e6">Exclude</a> (const void *&amp;elt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the first occurence of element.  <a href="#aea4b69afb050ab924e3783e2cbc026e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#abc85fe03209ed7d13614f7f671caf812">Exclude</a> (const <a class="el" href="classSgVector.html">SgVector</a>&lt; void * &gt; &amp;vector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exclude each element of <code>vector</code> from this vector.  <a href="#abc85fe03209ed7d13614f7f671caf812"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#af294dfc037c4620a5ad9313fb999318d">Index</a> (const void *&amp;elt) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find position of element.  <a href="#af294dfc037c4620a5ad9313fb999318d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#aac61591753b5fac6a49eb72de1ce221d">Include</a> (const void *&amp;elt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push <code>elt</code> to the back of the vector only if it is not included yet.  <a href="#aac61591753b5fac6a49eb72de1ce221d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a4277539f9259b2e6dda5dcd1a701f100">Insert</a> (const void *&amp;elt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Includes the element in a ascending sorted vector at the right place.  <a href="#a4277539f9259b2e6dda5dcd1a701f100"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a2ff3dbea2d4d5629649abba5222aecd3">IsEmpty</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether this vector contains zero elements.  <a href="#a2ff3dbea2d4d5629649abba5222aecd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a7d215fbe59aab0d2177e019e4438233d">IsLength</a> (int length) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether a vector is as long as a given length.  <a href="#a7d215fbe59aab0d2177e019e4438233d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a855ed4095823747183d76881b54b1c80">IsSorted</a> (bool ascending=true) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the vector is sorted in given order.  <a href="#a855ed4095823747183d76881b54b1c80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#ab0d80f1f24cde54196cc48a681cb9607">IsSortedAndUnique</a> (bool ascending=true) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the vector is sorted and has no duplicates.  <a href="#ab0d80f1f24cde54196cc48a681cb9607"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a3ca8aaa82a04c0a7bad34bf59b7b6d6c">Length</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of elements in this vector.  <a href="#a3ca8aaa82a04c0a7bad34bf59b7b6d6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a43547c97d9136ccb91d269480766c6d6">LimitListLength</a> (int limit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cut off vector after at most <code>length</code> elements.  <a href="#a43547c97d9136ccb91d269480766c6d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#aeba3788ca2e2cfa447222ad29a63b36e">MaxLength</a> (int length) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether a vector is shorter than or equal to a given length.  <a href="#aeba3788ca2e2cfa447222ad29a63b36e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#adf780dbf935ce42b5e55fea0ab4d5a08">Merge</a> (const <a class="el" href="classSgVector.html">SgVector</a>&lt; void * &gt; &amp;vector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merges two sorted vectors into this.  <a href="#adf780dbf935ce42b5e55fea0ab4d5a08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a1d4923765f78e048c1187d93f96a3305">MinLength</a> (int length) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether a vector is as long as or longer than a given length.  <a href="#a1d4923765f78e048c1187d93f96a3305"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a9239cad369a0e6516a685a5acbf82ac9">NonEmpty</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether this vector contains more than zero elements.  <a href="#a9239cad369a0e6516a685a5acbf82ac9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#aadabd21e224a515e98f555347e85f8d6">PopBack</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the last element of the vector.  <a href="#aadabd21e224a515e98f555347e85f8d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a620b0abc5c0ee8b2db8ca0d591089246">PushFront</a> (const void *&amp;elt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert element at the beginning of the vector.  <a href="#a620b0abc5c0ee8b2db8ca0d591089246"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a3e1db108668625555870efee073b2474">PushBack</a> (const void *&amp;elt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a single element at the end of the vector.  <a href="#a3e1db108668625555870efee073b2474"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a05f481ac39b08b8ee1f84cb41d93f099">PushBackList</a> (const <a class="el" href="classSgVector.html">SgVector</a>&lt; void * &gt; &amp;vector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push all elements from <code>vector</code> to the back of this.  <a href="#a05f481ac39b08b8ee1f84cb41d93f099"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a8f195ac12971b9280b4fb4ed96383716">RemoveDuplicates</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all but the first copy of each element from the vector.  <a href="#a8f195ac12971b9280b4fb4ed96383716"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a1cd6c488f58cf11e185c707dcad63415">Reverse</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a32f72054b47a6ba68fc2b07022900189">SetTo</a> (const void *&amp;elt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear this vector and set it to contain only <code>elt</code>.  <a href="#a32f72054b47a6ba68fc2b07022900189"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a40b30a04ab68b3e86a5df5e35b7f6672">SetTo</a> (const void **array, int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear this vector and set it to contain the <code>count</code> elements from <code>array[0]</code> to <code>array[count - 1]</code>.  <a href="#a40b30a04ab68b3e86a5df5e35b7f6672"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#abcf6c69bfba7636783138dde8bfea0a8">SetsAreEqual</a> (const <a class="el" href="classSgVector.html">SgVector</a>&lt; void * &gt; &amp;other) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do vectors contain the same elements, possibly in different order?  <a href="#abcf6c69bfba7636783138dde8bfea0a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a70405c0e0ecc386bdabae3fea68a18a3">Sort</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a85b77f48d4892cc2600d284cb506d32c">SortedRemoveDuplicates</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">remove duplicates in a sorted vector  <a href="#a85b77f48d4892cc2600d284cb506d32c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a7a20ccd8bd398f7fc5be6abe44611634">SwapWith</a> (<a class="el" href="classSgVector.html">SgVector</a>&lt; void * &gt; *vector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the entire contents of this vector with <code>*vector</code>.  <a href="#a7a20ccd8bd398f7fc5be6abe44611634"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void *&amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a2e623ed82fe0c92a928b32b923e804a2">TopNth</a> (int index) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the Nth-last element of the vector.  <a href="#a2e623ed82fe0c92a928b32b923e804a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#ade0e9912a21e3b0ba93f048a938d61f4">Union</a> (const <a class="el" href="classSgVector.html">SgVector</a>&lt; void * &gt; &amp;set)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Include all elements from <code>set</code> into this vector.  <a href="#ade0e9912a21e3b0ba93f048a938d61f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#afa99ebf0ee90846a9e2e7eec76c92154">UniqueElements</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for duplicate elements.  <a href="#afa99ebf0ee90846a9e2e7eec76c92154"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; void * &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a51f26434eadeabd04226571a9abdf407">Vector</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::vector&lt; void * &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVector.html#a7b0d8bcf14f1a0d9aa9fddd52e82dcb6">Vector</a> () const</td></tr>
<tr><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSgVectorOf.html#a419fa77a58a005f0ef4bf4d77c575e91">GetVoidPtr</a> (const T *element)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion of element pointer to non-const void pointer.  <a href="#a419fa77a58a005f0ef4bf4d77c575e91"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br/>
 class SgVectorOf&lt; T &gt;</h3>

<p>Typed vector of pointers to T. </p>
<p>Pointers cannot be 0. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00344">344</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af5ac4b3fd17c0d3df5dbb535eece5020"></a><!-- doxytag: member="SgVectorOf::Back" ref="af5ac4b3fd17c0d3df5dbb535eece5020" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt;::Back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the last element of the vector. </p>
<p>Asserts if the vector is empty. </p>

<p>Reimplemented from <a class="el" href="classSgVector.html#ad147ca492327f79012149631bb0ce0c3">SgVector&lt; void * &gt;</a>.</p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00354">354</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>Referenced by <a class="el" href="SgVector_8h_source.html#l00354">SgVectorOf&lt; std::string &gt;::Back()</a>.</p>

</div>
</div>
<a class="anchor" id="a40a18e1bd8196a7f922818a453ba429e"></a><!-- doxytag: member="SgVectorOf::BackAndPop" ref="a40a18e1bd8196a7f922818a453ba429e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void *  <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::BackAndPop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00064">64</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00280">SgVector&lt; T &gt;::m_vec</a>, <a class="el" href="SgVector_8h_source.html#l00180">SgVector&lt; T &gt;::NonEmpty()</a>, <a class="el" href="SgVector_8h_source.html#l00617">SgVector&lt; T &gt;::PopBack()</a>, and <a class="el" href="SgSystem_8h_source.html#l00088">SG_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a5ff70a14db39eef24ee4fb9b9630922c"></a><!-- doxytag: member="SgVectorOf::Clear" ref="a5ff70a14db39eef24ee4fb9b9630922c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove all elements in this vector. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00073">73</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00280">SgVector&lt; T &gt;::m_vec</a>.</p>

<p>Referenced by <a class="el" href="SgVector_8h_source.html#l00817">FreeAll()</a>, <a class="el" href="SgNode_8cpp_source.html#l00229">SgNode::PathToRoot()</a>, <a class="el" href="SgGameReader_8cpp_source.html#l00122">SgGameReader::ReadGames()</a>, and <a class="el" href="SgNode_8cpp_source.html#l00347">SgNode::ShortestPathTo()</a>.</p>

</div>
</div>
<a class="anchor" id="aaed64fdb221f8c2455891607b03e2e1a"></a><!-- doxytag: member="SgVectorOf::Concat" ref="aaed64fdb221f8c2455891607b03e2e1a" args="(SgVector&lt; void * &gt; *tail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt; *&nbsp;</td>
          <td class="paramname"> <em>tail</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push all of <code>*tail</code> to the back of this vector, and clear the <code>*tail</code> vector. </p>
<p>Remark: this operation is efficient for lists but not so meaningful for vectors. PushBackList may be more appropriate in most cases. </p>

</div>
</div>
<a class="anchor" id="abc43a6f3a6a438e470a289ef64b4168d"></a><!-- doxytag: member="SgVectorOf::Contains" ref="abc43a6f3a6a438e470a289ef64b4168d" args="(const void *&amp;elt) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Contains </td>
          <td>(</td>
          <td class="paramtype">const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>elt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if element is in vector. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <code>elt</code> is included in this vector, <code>false</code> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e687bc1a090b418a28ec41921ae67af"></a><!-- doxytag: member="SgVectorOf::Contains" ref="a2e687bc1a090b418a28ec41921ae67af" args="(const T *element) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt;::Contains </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00359">359</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>Referenced by <a class="el" href="SgVector_8h_source.html#l00359">SgVectorOf&lt; std::string &gt;::Contains()</a>, and <a class="el" href="SgVector_8h_source.html#l00367">SgVectorOf&lt; std::string &gt;::Include()</a>.</p>

</div>
</div>
<a class="anchor" id="a570f5f72b2aa5ac445b83c64e63f5f11"></a><!-- doxytag: member="SgVectorOf::DeleteAt" ref="a570f5f72b2aa5ac445b83c64e63f5f11" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::DeleteAt </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>delete element at specified index </p>

</div>
</div>
<a class="anchor" id="ac7893f0d0532bcb662d069a86f174cab"></a><!-- doxytag: member="SgVectorOf::Exclude" ref="ac7893f0d0532bcb662d069a86f174cab" args="(const T *element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt;::Exclude </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00374">374</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>Referenced by <a class="el" href="SgVector_8h_source.html#l00374">SgVectorOf&lt; std::string &gt;::Exclude()</a>, <a class="el" href="SgProp_8cpp_source.html#l00189">SgPropList::MoveToFront()</a>, and <a class="el" href="SgProp_8cpp_source.html#l00196">SgPropList::Remove()</a>.</p>

</div>
</div>
<a class="anchor" id="aea4b69afb050ab924e3783e2cbc026e6"></a><!-- doxytag: member="SgVectorOf::Exclude" ref="aea4b69afb050ab924e3783e2cbc026e6" args="(const void *&amp;elt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Exclude </td>
          <td>(</td>
          <td class="paramtype">const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>elt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the first occurence of element. </p>
<p>If <code>elt</code> is in the vector, remove the first occurence of <code>elt</code> from the vector, and return <code>true</code>. Otherwise do nothing and return <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="abc85fe03209ed7d13614f7f671caf812"></a><!-- doxytag: member="SgVectorOf::Exclude" ref="abc85fe03209ed7d13614f7f671caf812" args="(const SgVector&lt; void * &gt; &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Exclude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exclude each element of <code>vector</code> from this vector. </p>

</div>
</div>
<a class="anchor" id="a2cc01d290f43682f180bb81afc3c256c"></a><!-- doxytag: member="SgVectorOf::Exclude" ref="a2cc01d290f43682f180bb81afc3c256c" args="(const SgVectorOf&lt; T &gt; &amp;vector)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt;::Exclude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00379">379</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a85b09b37995786453410cb1f5bc3e58b"></a><!-- doxytag: member="SgVectorOf::Front" ref="a85b09b37995786453410cb1f5bc3e58b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt;::Front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the first element of the vector. </p>
<p>Asserts if the vector is empty. </p>

<p>Reimplemented from <a class="el" href="classSgVector.html#a0c03fdc4982501a60b913a13401dcd8b">SgVector&lt; void * &gt;</a>.</p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00384">384</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>Referenced by <a class="el" href="SgVector_8h_source.html#l00384">SgVectorOf&lt; std::string &gt;::Front()</a>.</p>

</div>
</div>
<a class="anchor" id="a419fa77a58a005f0ef4bf4d77c575e91"></a><!-- doxytag: member="SgVectorOf::GetVoidPtr" ref="a419fa77a58a005f0ef4bf4d77c575e91" args="(const T *element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void* <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt;::GetVoidPtr </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Conversion of element pointer to non-const void pointer. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Not sure if there is a better way without needing the const cast. </dd></dl>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00429">429</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>Referenced by <a class="el" href="SgVector_8h_source.html#l00359">SgVectorOf&lt; std::string &gt;::Contains()</a>, <a class="el" href="SgVector_8h_source.html#l00374">SgVectorOf&lt; std::string &gt;::Exclude()</a>, <a class="el" href="SgVector_8h_source.html#l00389">SgVectorOf&lt; std::string &gt;::Insert()</a>, <a class="el" href="SgVector_8h_source.html#l00400">SgVectorOf&lt; std::string &gt;::PushBack()</a>, and <a class="el" href="SgVector_8h_source.html#l00394">SgVectorOf&lt; std::string &gt;::PushFront()</a>.</p>

</div>
</div>
<a class="anchor" id="a28080e1902982c62a1b1681ce221a500"></a><!-- doxytag: member="SgVectorOf::Include" ref="a28080e1902982c62a1b1681ce221a500" args="(const T *element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt;::Include </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push <code>elt</code> to the back of the vector unless it is already included. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00367">367</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>Referenced by <a class="el" href="SgProp_8cpp_source.html#l00168">SgPropList::Add()</a>.</p>

</div>
</div>
<a class="anchor" id="aac61591753b5fac6a49eb72de1ce221d"></a><!-- doxytag: member="SgVectorOf::Include" ref="aac61591753b5fac6a49eb72de1ce221d" args="(const void *&amp;elt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Include </td>
          <td>(</td>
          <td class="paramtype">const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>elt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push <code>elt</code> to the back of the vector only if it is not included yet. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00118">118</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00490">SgVector&lt; T &gt;::Contains()</a>, and <a class="el" href="SgVector_8h_source.html#l00202">SgVector&lt; T &gt;::PushBack()</a>.</p>

</div>
</div>
<a class="anchor" id="af294dfc037c4620a5ad9313fb999318d"></a><!-- doxytag: member="SgVectorOf::Index" ref="af294dfc037c4620a5ad9313fb999318d" args="(const void *&amp;elt) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Index </td>
          <td>(</td>
          <td class="paramtype">const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>elt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find position of element. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The position of <code>elt</code> in the vector, in range <code>0..length-1</code>. Returns -1 if <code>elt</code> is not in the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a40c9718e827f321f80c62d9065cfaf38"></a><!-- doxytag: member="SgVectorOf::Insert" ref="a40c9718e827f321f80c62d9065cfaf38" args="(const T *element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt;::Insert </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00389">389</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>Referenced by <a class="el" href="SgVector_8h_source.html#l00389">SgVectorOf&lt; std::string &gt;::Insert()</a>.</p>

</div>
</div>
<a class="anchor" id="a4277539f9259b2e6dda5dcd1a701f100"></a><!-- doxytag: member="SgVectorOf::Insert" ref="a4277539f9259b2e6dda5dcd1a701f100" args="(const void *&amp;elt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Insert </td>
          <td>(</td>
          <td class="paramtype">const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>elt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Includes the element in a ascending sorted vector at the right place. </p>
<p>Does nothing and returns <code>false</code> if the element is already in the vector; returns <code>true</code> if the element is inserted. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>made two separate functions for efficiency, should be a template taking a compare template arg. Same for <code><a class="el" href="classSgVector.html#adf780dbf935ce42b5e55fea0ab4d5a08" title="Merges two sorted vectors into this.">Merge()</a></code> below. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ff3dbea2d4d5629649abba5222aecd3"></a><!-- doxytag: member="SgVectorOf::IsEmpty" ref="a2ff3dbea2d4d5629649abba5222aecd3" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return whether this vector contains zero elements. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00134">134</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00280">SgVector&lt; T &gt;::m_vec</a>.</p>

</div>
</div>
<a class="anchor" id="a7d215fbe59aab0d2177e019e4438233d"></a><!-- doxytag: member="SgVectorOf::IsLength" ref="a7d215fbe59aab0d2177e019e4438233d" args="(int length) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::IsLength </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether a vector is as long as a given length. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00140">140</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00152">SgVector&lt; T &gt;::Length()</a>.</p>

</div>
</div>
<a class="anchor" id="a855ed4095823747183d76881b54b1c80"></a><!-- doxytag: member="SgVectorOf::IsSorted" ref="a855ed4095823747183d76881b54b1c80" args="(bool ascending=true) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::IsSorted </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ascending</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the vector is sorted in given order. </p>

</div>
</div>
<a class="anchor" id="ab0d80f1f24cde54196cc48a681cb9607"></a><!-- doxytag: member="SgVectorOf::IsSortedAndUnique" ref="ab0d80f1f24cde54196cc48a681cb9607" args="(bool ascending=true) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::IsSortedAndUnique </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ascending</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the vector is sorted and has no duplicates. </p>

</div>
</div>
<a class="anchor" id="a3ca8aaa82a04c0a7bad34bf59b7b6d6c"></a><!-- doxytag: member="SgVectorOf::Length" ref="a3ca8aaa82a04c0a7bad34bf59b7b6d6c" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of elements in this vector. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00152">152</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00280">SgVector&lt; T &gt;::m_vec</a>.</p>

</div>
</div>
<a class="anchor" id="a43547c97d9136ccb91d269480766c6d6"></a><!-- doxytag: member="SgVectorOf::LimitListLength" ref="a43547c97d9136ccb91d269480766c6d6" args="(int limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::LimitListLength </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>limit</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cut off vector after at most <code>length</code> elements. </p>

</div>
</div>
<a class="anchor" id="aeba3788ca2e2cfa447222ad29a63b36e"></a><!-- doxytag: member="SgVectorOf::MaxLength" ref="aeba3788ca2e2cfa447222ad29a63b36e" args="(int length) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::MaxLength </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether a vector is shorter than or equal to a given length. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00161">161</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00152">SgVector&lt; T &gt;::Length()</a>.</p>

</div>
</div>
<a class="anchor" id="adf780dbf935ce42b5e55fea0ab4d5a08"></a><!-- doxytag: member="SgVectorOf::Merge" ref="adf780dbf935ce42b5e55fea0ab4d5a08" args="(const SgVector&lt; void * &gt; &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges two sorted vectors into this. </p>
<p>Equivalent to, but faster than: </p>
<pre>
        for (SgVectorIterator&lt;T&gt; it(vector); it; ++it)
            Insert(*it);
        </pre> 
</div>
</div>
<a class="anchor" id="a1d4923765f78e048c1187d93f96a3305"></a><!-- doxytag: member="SgVectorOf::MinLength" ref="a1d4923765f78e048c1187d93f96a3305" args="(int length) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::MinLength </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test whether a vector is as long as or longer than a given length. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00174">174</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00152">SgVector&lt; T &gt;::Length()</a>.</p>

</div>
</div>
<a class="anchor" id="a9239cad369a0e6516a685a5acbf82ac9"></a><!-- doxytag: member="SgVectorOf::NonEmpty" ref="a9239cad369a0e6516a685a5acbf82ac9" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::NonEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return whether this vector contains more than zero elements. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00180">180</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00134">SgVector&lt; T &gt;::IsEmpty()</a>.</p>

</div>
</div>
<a class="anchor" id="a5cc61a0421557942a6159f67d9faed32"></a><!-- doxytag: member="SgVectorOf::operator!=" ref="a5cc61a0421557942a6159f67d9faed32" args="(const SgVector &amp;rhs) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgVector.html">SgVector</a>&lt; void * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare whether the contents of two vectors are not identical. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00051">51</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab01cd66d227fdaa8ab91db708d22dcbf"></a><!-- doxytag: member="SgVectorOf::operator==" ref="ab01cd66d227fdaa8ab91db708d22dcbf" args="(const SgVector&lt; void * &gt; &amp;rhs) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare whether the contents of two vectors are identical. </p>
<p>Same length, and the same elements in the same sequence. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00045">45</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00280">SgVector&lt; T &gt;::m_vec</a>.</p>

</div>
</div>
<a class="anchor" id="a3137ccc12c5366ccb990a93350d1db75"></a><!-- doxytag: member="SgVectorOf::operator[]" ref="a3137ccc12c5366ccb990a93350d1db75" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return const reference to element. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Position of element in range <code>0..length-1</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classSgVector.html#ad37fc9892ddb55494461412be3a84304">SgVector&lt; void * &gt;</a>.</p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00349">349</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>Referenced by <a class="el" href="SgVector_8h_source.html#l00349">SgVectorOf&lt; std::string &gt;::operator[]()</a>.</p>

</div>
</div>
<a class="anchor" id="a574064d880ced8e2bfe6267fb4cc5c3b"></a><!-- doxytag: member="SgVectorOf::operator[]" ref="a574064d880ced8e2bfe6267fb4cc5c3b" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * &amp; <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return reference to element. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Position of element in range <code>0..length-1</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00027">27</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00280">SgVector&lt; T &gt;::m_vec</a>.</p>

</div>
</div>
<a class="anchor" id="aadabd21e224a515e98f555347e85f8d6"></a><!-- doxytag: member="SgVectorOf::PopBack" ref="aadabd21e224a515e98f555347e85f8d6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::PopBack </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the last element of the vector. </p>
<p>The vector must not be empty. </p>

</div>
</div>
<a class="anchor" id="ac2747bfdbf87580d10fd41aee9d82c7d"></a><!-- doxytag: member="SgVectorOf::PopFront" ref="ac2747bfdbf87580d10fd41aee9d82c7d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt;::PopFront </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove element[0] of the vector. </p>
<p>The vector must not be empty. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The element[0] of the original vector before removal. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Don't use this function; it is slow. Only exists for SgList compatibility. </dd></dl>

<p>Reimplemented from <a class="el" href="classSgVector.html#ac88e3737cbdcf96b66202648ba732066">SgVector&lt; void * &gt;</a>.</p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00406">406</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>Referenced by <a class="el" href="SgVector_8h_source.html#l00406">SgVectorOf&lt; std::string &gt;::PopFront()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e1db108668625555870efee073b2474"></a><!-- doxytag: member="SgVectorOf::PushBack" ref="a3e1db108668625555870efee073b2474" args="(const void *&amp;elt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::PushBack </td>
          <td>(</td>
          <td class="paramtype">const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>elt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a single element at the end of the vector. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00202">202</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00152">SgVector&lt; T &gt;::Length()</a>, <a class="el" href="SgVector_8h_source.html#l00280">SgVector&lt; T &gt;::m_vec</a>, and <a class="el" href="SgSystem_8h_source.html#l00088">SG_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="a9766e2f06df99110cfe2a093aed86779"></a><!-- doxytag: member="SgVectorOf::PushBack" ref="a9766e2f06df99110cfe2a093aed86779" args="(const T *element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt;::PushBack </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00400">400</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>Referenced by <a class="el" href="SgProp_8cpp_source.html#l01122">SgPropTextList::AddStringAtPoint()</a>, <a class="el" href="SgVector_8h_source.html#l00367">SgVectorOf&lt; std::string &gt;::Include()</a>, <a class="el" href="SgNode_8cpp_source.html#l00229">SgNode::PathToRoot()</a>, <a class="el" href="SgVector_8h_source.html#l00400">SgVectorOf&lt; std::string &gt;::PushBack()</a>, <a class="el" href="SgGameReader_8cpp_source.html#l00122">SgGameReader::ReadGames()</a>, <a class="el" href="SgProp_8cpp_source.html#l00203">SgPropList::Remove()</a>, <a class="el" href="SgProp_8cpp_source.html#l01086">SgPropTextList::SgPropTextList()</a>, and <a class="el" href="SgNode_8cpp_source.html#l00347">SgNode::ShortestPathTo()</a>.</p>

</div>
</div>
<a class="anchor" id="a05f481ac39b08b8ee1f84cb41d93f099"></a><!-- doxytag: member="SgVectorOf::PushBackList" ref="a05f481ac39b08b8ee1f84cb41d93f099" args="(const SgVector&lt; void * &gt; &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::PushBackList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push all elements from <code>vector</code> to the back of this. </p>

</div>
</div>
<a class="anchor" id="a620b0abc5c0ee8b2db8ca0d591089246"></a><!-- doxytag: member="SgVectorOf::PushFront" ref="a620b0abc5c0ee8b2db8ca0d591089246" args="(const void *&amp;elt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::PushFront </td>
          <td>(</td>
          <td class="paramtype">const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>elt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert element at the beginning of the vector. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Don't use this function; it is slow. Only exists for SgList compatibility. </dd></dl>

</div>
</div>
<a class="anchor" id="abdcbd46ebf329701ff97315f142db56e"></a><!-- doxytag: member="SgVectorOf::PushFront" ref="abdcbd46ebf329701ff97315f142db56e" args="(const T *element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVectorOf.html">SgVectorOf</a>&lt; T &gt;::PushFront </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00394">394</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>Referenced by <a class="el" href="SgProp_8cpp_source.html#l00189">SgPropList::MoveToFront()</a>, and <a class="el" href="SgVector_8h_source.html#l00394">SgVectorOf&lt; std::string &gt;::PushFront()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f195ac12971b9280b4fb4ed96383716"></a><!-- doxytag: member="SgVectorOf::RemoveDuplicates" ref="a8f195ac12971b9280b4fb4ed96383716" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::RemoveDuplicates </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all but the first copy of each element from the vector. </p>
<p>After calling <code><a class="el" href="classSgVector.html#a8f195ac12971b9280b4fb4ed96383716" title="Removes all but the first copy of each element from the vector.">RemoveDuplicates()</a></code>, <code><a class="el" href="classSgVector.html#afa99ebf0ee90846a9e2e7eec76c92154" title="Check for duplicate elements.">UniqueElements()</a></code> is <code>true</code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true, if at least one duplicate was removed </dd></dl>

</div>
</div>
<a class="anchor" id="a1cd6c488f58cf11e185c707dcad63415"></a><!-- doxytag: member="SgVectorOf::Reverse" ref="a1cd6c488f58cf11e185c707dcad63415" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Reverse </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00217">217</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00280">SgVector&lt; T &gt;::m_vec</a>.</p>

<p>Referenced by <a class="el" href="SgNode_8cpp_source.html#l00347">SgNode::ShortestPathTo()</a>.</p>

</div>
</div>
<a class="anchor" id="abcf6c69bfba7636783138dde8bfea0a8"></a><!-- doxytag: member="SgVectorOf::SetsAreEqual" ref="abcf6c69bfba7636783138dde8bfea0a8" args="(const SgVector&lt; void * &gt; &amp;other) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::SetsAreEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do vectors contain the same elements, possibly in different order? </p>

</div>
</div>
<a class="anchor" id="a32f72054b47a6ba68fc2b07022900189"></a><!-- doxytag: member="SgVectorOf::SetTo" ref="a32f72054b47a6ba68fc2b07022900189" args="(const void *&amp;elt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::SetTo </td>
          <td>(</td>
          <td class="paramtype">const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>elt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear this vector and set it to contain only <code>elt</code>. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00223">223</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00073">SgVector&lt; T &gt;::Clear()</a>, and <a class="el" href="SgVector_8h_source.html#l00202">SgVector&lt; T &gt;::PushBack()</a>.</p>

</div>
</div>
<a class="anchor" id="a40b30a04ab68b3e86a5df5e35b7f6672"></a><!-- doxytag: member="SgVectorOf::SetTo" ref="a40b30a04ab68b3e86a5df5e35b7f6672" args="(const void **array, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::SetTo </td>
          <td>(</td>
          <td class="paramtype">const void *  *&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear this vector and set it to contain the <code>count</code> elements from <code>array[0]</code> to <code>array[count - 1]</code>. </p>
<p>If <code>count</code> is zero, the vector is just cleared. </p>

</div>
</div>
<a class="anchor" id="a70405c0e0ecc386bdabae3fea68a18a3"></a><!-- doxytag: member="SgVectorOf::Sort" ref="a70405c0e0ecc386bdabae3fea68a18a3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Sort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a85b77f48d4892cc2600d284cb506d32c"></a><!-- doxytag: member="SgVectorOf::SortedRemoveDuplicates" ref="a85b77f48d4892cc2600d284cb506d32c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::SortedRemoveDuplicates </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>remove duplicates in a sorted vector </p>

</div>
</div>
<a class="anchor" id="a7a20ccd8bd398f7fc5be6abe44611634"></a><!-- doxytag: member="SgVectorOf::SwapWith" ref="a7a20ccd8bd398f7fc5be6abe44611634" args="(SgVector&lt; void * &gt; *vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::SwapWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt; *&nbsp;</td>
          <td class="paramname"> <em>vector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap the entire contents of this vector with <code>*vector</code>. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00244">244</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00280">SgVector&lt; T &gt;::m_vec</a>.</p>

</div>
</div>
<a class="anchor" id="a2e623ed82fe0c92a928b32b923e804a2"></a><!-- doxytag: member="SgVectorOf::TopNth" ref="a2e623ed82fe0c92a928b32b923e804a2" args="(int index) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * &amp; <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::TopNth </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the Nth-last element of the vector. </p>
<p>It must exist. </p>

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00250">250</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00280">SgVector&lt; T &gt;::m_vec</a>, <a class="el" href="SgVector_8h_source.html#l00180">SgVector&lt; T &gt;::NonEmpty()</a>, and <a class="el" href="SgSystem_8h_source.html#l00088">SG_ASSERT</a>.</p>

</div>
</div>
<a class="anchor" id="ade0e9912a21e3b0ba93f048a938d61f4"></a><!-- doxytag: member="SgVectorOf::Union" ref="ade0e9912a21e3b0ba93f048a938d61f4" args="(const SgVector&lt; void * &gt; &amp;set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>set</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Include all elements from <code>set</code> into this vector. </p>
<p>Appends new elements at the end of this vector. </p>

</div>
</div>
<a class="anchor" id="afa99ebf0ee90846a9e2e7eec76c92154"></a><!-- doxytag: member="SgVectorOf::UniqueElements" ref="afa99ebf0ee90846a9e2e7eec76c92154" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::UniqueElements </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check for duplicate elements. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if there are no duplicate elements in the vector. Useful for debugging. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>speed it up </dd></dl>

</div>
</div>
<a class="anchor" id="a51f26434eadeabd04226571a9abdf407"></a><!-- doxytag: member="SgVectorOf::Vector" ref="a51f26434eadeabd04226571a9abdf407" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;void * &gt;&amp; <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Vector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00269">269</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00280">SgVector&lt; T &gt;::m_vec</a>.</p>

</div>
</div>
<a class="anchor" id="a7b0d8bcf14f1a0d9aa9fddd52e82dcb6"></a><!-- doxytag: member="SgVectorOf::Vector" ref="a7b0d8bcf14f1a0d9aa9fddd52e82dcb6" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;void * &gt;&amp; <a class="el" href="classSgVector.html">SgVector</a>&lt; void *  &gt;::Vector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SgVector_8h_source.html#l00274">274</a> of file <a class="el" href="SgVector_8h_source.html">SgVector.h</a>.</p>

<p>References <a class="el" href="SgVector_8h_source.html#l00280">SgVector&lt; T &gt;::m_vec</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SgVector_8h_source.html">SgVector.h</a></li>
</ul>
</div>
<p>
<hr>
<div style="text-align:right;">
Sun Mar 13 2011 <a href="http://www.doxygen.org/">Doxygen</a> 1.7.1
</div>
</p>
</body>

<!-- Mirrored from fuego.sourceforge.net/fuego-doc-1.1/smartgame-doc/classSgVectorOf.html by HTTrack Website Copier/3.x [XR&CO'2010], Wed, 25 Apr 2012 18:00:32 GMT -->
</html>
