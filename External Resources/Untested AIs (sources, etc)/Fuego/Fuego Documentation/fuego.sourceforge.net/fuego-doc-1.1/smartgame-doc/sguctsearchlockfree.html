<html>

<!-- Mirrored from fuego.sourceforge.net/fuego-doc-1.1/smartgame-doc/sguctsearchlockfree.html by HTTrack Website Copier/3.x [XR&CO'2010], Wed, 25 Apr 2012 18:01:20 GMT -->
<head>
<title>SmartGame Library: Lock-free mode in SgUctSearch</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<div class="qindex">
<a class="qindex" href="../main.html">Index</a> &nbsp;
<a class="qindex" href="index.html">Main</a> &nbsp;
<a class="qindex" href="namespaces.html">Namespaces</a> &nbsp;
<a class="qindex" href="classes.html">Classes</a> &nbsp;
<a class="qindex" href="hierarchy.html">Hierarchy</a> &nbsp;
<a class="qindex" href="annotated.html">Annotated</a> &nbsp;
<a class="qindex" href="files.html">Files</a> &nbsp;
<!--
<a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp;>
-->
<a class="qindex" href="functions.html">Compound</a> &nbsp;
<a class="qindex" href="globals.html">Global</a> &nbsp;
<a class="qindex" href="pages.html">Pages</a> &nbsp;
</div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="header">
  <div class="headertitle">
<h1>Lock-free mode in <a class="el" href="classSgUctSearch.html" title="Monte Carlo tree search using UCT.">SgUctSearch</a> </h1>  </div>
</div>
<div class="contents">
<p>The basic idea of the lock-free mode in <a class="el" href="classSgUctSearch.html" title="Monte Carlo tree search using UCT.">SgUctSearch</a> is to share a tree between multiple threads without using any locks.</p>
<p>Because of specific requirements on the memory model of the hardware platform, lock-free mode is an optional feature of the <a class="el" href="classSgUctSearch.html" title="Monte Carlo tree search using UCT.">SgUctSearch</a> and needs to be enabled explicitly.</p>
<h2><a class="anchor" id="sguctsearchlockfreetree"></a>
Modifying the Tree Structure</h2>
<p>The first change to make the lock-free search work is in the handling of concurrent changes to the structure of the tree. <a class="el" href="classSgUctSearch.html" title="Monte Carlo tree search using UCT.">SgUctSearch</a> never deletes nodes during a search; new nodes are created in a pre-allocated memory array. In the lock-free algorithm, each thread has its own memory array for creating new nodes. Only after the nodes are fully created and initialized, are they linked to the parent node. This can cause some memory overhead, because if several threads expand the same node only the children created by the last thread will be used in future simulations. It can also happen that some of the children that are lost already received value updates; these updates will be lost.</p>
<p>The child information of a node consists of two variables: a pointer to the first child in the array, and the number of children. To avoid that another thread sees an inconsistent state of these variables, all threads assume that the number of children is valid if the pointer to the first child is not null. Linking a parent to a new set of children requires first writing the number of children, then the pointer to the first child. The compiler is prevented from reordering the writes by declaring these variables as volatile.</p>
<h2><a class="anchor" id="sguctsearchlockfreevalues"></a>
Updating Values</h2>
<p>The move and RAVE values are stored in the nodes as counts and mean values. The mean values are updated using an incremental algorithm. Updating them without protection by a mutex can cause updates of the mean to be lost with or without increment of the count, as well as updates of the mean occurring without increment of the count. It could also happen that one thread reads the count and mean while they are written by another thread, and the first thread sees an erroneous state that exists only temporarily. In practice, these faulty updates occur with a low probability and will have only a small effect on the counts and mean values. They are intentionally ignored.</p>
<p>The only problematic case is if a count is zero, because the mean value is undefined if the count is zero, and this case has a special meaning at several places in the search. For example, the computation of the values for the selection of children in the in-tree phase distinguishes three cases: if the move count and RAVE count is non-zero, the value will be computed as a weighted linear combination of both mean values, if the move count is zero, only the RAVE mean is used, and if both counts are zero, a configurable constant value, the first play urgency, is used. To avoid this problem, all threads assume that a mean value is only valid if the corresponding count is non-zero. Updating a value requires first writing the new mean value, then the new count. The compiler is prevented from reordering the writes by declaring the counts and mean values as volatile.</p>
<h2><a class="anchor" id="sguctsearchlockfreeplatform"></a>
Platform Requirements</h2>
<p>There are some requirements on the memory model of the platform to make the lock-free search algorithm work. Writes of certain basic types (size_t, int, float, pointers) must be atomic. Writes by one thread must be seen by other threads in the same order. The IA-32 and Intel-64 CPU architectures, which are used in most modern standard computers, guarantee these assumptions. They also synchronize CPU caches after writes. (See <a href="http://download.intel.com/design/processor/manuals/253668.pdf">Intel 64 and IA-32 Architectures Software Developer's Manual</a>, chapter 7.1 Locked Atomic Operations and 7.2 Memory Ordering). </p>
</div>
<p>
<hr>
<div style="text-align:right;">
Sun Mar 13 2011 <a href="http://www.doxygen.org/">Doxygen</a> 1.7.1
</div>
</p>
</body>

<!-- Mirrored from fuego.sourceforge.net/fuego-doc-1.1/smartgame-doc/sguctsearchlockfree.html by HTTrack Website Copier/3.x [XR&CO'2010], Wed, 25 Apr 2012 18:01:20 GMT -->
</html>
