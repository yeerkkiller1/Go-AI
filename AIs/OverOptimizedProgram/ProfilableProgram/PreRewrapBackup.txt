using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GTPLibrary;
using System.Threading;

namespace ProfilableProgram
{
    class Program
    {
        static void Main(string[] args)
        {
            RecurseSpeedTest();
            //GTPInterface test = new GTPInterface();
        }

        //Original:
        //  60/s (with accidental debug code left)
        //  140/s (with debug code removed, minor unlikely infinte recursion bug)

        static void RecurseSpeedTest()
        {
            int boardSampleCount = 280;
            int tryPlayCount = 1; //We try to play this amount of pieces, but with overlap we may play less

            Random random = new Random();

            int[][,] boardSamples = new int[boardSampleCount][,];
            for (int x = 0; x < boardSampleCount; x++)
            {
                boardSamples[x] = new int[9, 9];
                for (int y = 0; y < tryPlayCount; y++)
                {
                    int xPos = random.Next(9); int yPos = random.Next(9);
                    if (boardSamples[x][xPos, yPos] == 0)
                        boardSamples[x][xPos, yPos] = (y % 2) + 1;
                }
            }

            int[][,] forcedOutput = new int[boardSampleCount][,];

            long speedTestOne = DateTime.Now.Ticks;
            
            double averagePlainBoard = 0;
            //Just make sure they are the same (as it is a deterministic test anyway)
            for (int x = 0; x < boardSampleCount; x++)
                averagePlainBoard += TestDotNetGoPlayer.MonteCarloForBlackMetadata(true, boardSamples[x], 0, 0);
                //averagePlainBoard += TestDotNetGoPlayer.MonteCarloForBlack(true, boardSamples[x], 0, 0);
            averagePlainBoard /= boardSampleCount;

            speedTestOne = DateTime.Now.Ticks - speedTestOne;

            /*
            long speedTestTwo = DateTime.Now.Ticks;
            for (int x = 0; x < boardSampleCount; x++)
            {
                forcedOutput[x] = new int[9, 9];
                TestDotNetGoPlayer.CreateLibertyGroupsOther(boardSamples[x], forcedOutput[x]);
            }
            speedTestTwo = DateTime.Now.Ticks - speedTestTwo;
            */

            /*
            speedTestOne = DateTime.Now.Ticks;
            for (int x = 0; x < boardSampleCount; x++)
            {
                forcedOutput[x] = new int[9, 9];
                TestDotNetGoPlayer.CreateLibertyGroups(boardSamples[x], forcedOutput[x]);
            }
            speedTestOne = DateTime.Now.Ticks - speedTestOne;
            */
        }

        //1400-lines pre code rewrap
        public class TestDotNetGoPlayer : SimpleGoPlayer
        {
            public int[,] board = new int[9, 9]; // 0 empty, 1 - black, 2 - white
            //-10 is black territory, -20 is white territory

            public  static double komi = -6.5; //SHOULD NOT BE STATIC

            public TestDotNetGoPlayer()
            {

            }

            //public TestDotNetGoPlayer
            public override Ent_vertex GetAndPlayMove(string color)
            {
                //Go a few ply deep, then min/max with montecarlo algorithm to find best
                Ent_vertex vertex;
                double bestWinRate;
                vertex = GetBest(color == "b", color == "b", board, 1, 0, out bestWinRate);

                return vertex;
            }

            //Ent_vertex is only really used on the last return
            public Ent_vertex GetBest(bool curBlack, bool blackUs, int[,] curBoard, int plyDeep, int curPly, out double bestWinRate)
            {
                if (plyDeep == curPly) //We do not go deeper, just do monte-carlo and then return
                {
                    //ATTENTION, we should really keep track of caps before now, or atleast actually calculate them now!
                    //However if we do right here it will change our parent, and we will either have to keep copying 
                    //curBoard or reverse the changes here

                    //removeCapturesFinal(curBoard, libertyGroups, ref blackCaps, ref whiteCaps);

                    int blackCaps = 0, whiteCaps = 0;

                    bestWinRate = MonteCarloForBlack(curBlack, curBoard, blackCaps, whiteCaps);

                    if (!curBlack)
                        bestWinRate = 1 - bestWinRate;
                    return null;
                }

                //Search deeper

                //From curBoard split up... do all possibility for now                        
                double[,] bestWinRates = new double[9, 9];

                int[,] tempNewBoard = new int[9, 9];
                Array.Copy(curBoard, tempNewBoard, 9 * 9);

                int curColor = curBlack ? 1 : 2;
                int ourColor = blackUs ? 1 : 2;

                for (int x = 0; x < 9; x++)
                    for (int y = 0; y < 9; y++)
                    {
                        if (tempNewBoard[x, y] != 0)
                            continue;

                        tempNewBoard[x, y] = curColor; //Place it

                        //Test it
                        GetBest(!curBlack, blackUs, tempNewBoard, plyDeep, curPly + 1, out bestWinRates[x, y]);

                        //Remove it
                        tempNewBoard[x, y] = 0;
                    }

                if (curBlack == blackUs) //We just choose the best
                {
                    Ent_vertex bestVertex = null;
                    double bestRate = 0;

                    for (int x = 0; x < 9; x++)
                        for (int y = 0; y < 9; y++)
                            if (bestWinRates[x, y] > bestRate)
                            {
                                bestRate = bestWinRates[x, y];
                                bestVertex = new Ent_vertex(x, y);
                            }

                    bestWinRate = bestRate;
                    return bestVertex;
                }
                else //We choose the worst (as it is not our turn, and the enemy chooses their best (our worst))
                {
                    Ent_vertex bestVertex = null;
                    double bestRate = double.MaxValue;

                    for (int x = 0; x < 9; x++)
                        for (int y = 0; y < 9; y++)
                            if (bestWinRates[x, y] < bestRate && bestWinRates[x, y] != 0)
                            {
                                bestRate = bestWinRates[x, y];
                                bestVertex = new Ent_vertex(x, y);
                            }

                    bestWinRate = bestRate;
                    return bestVertex;
                }

            }



            public static double MonteCarloForBlack(bool curBlack, int[,] curBoard, int blackCaps, int whiteCaps)
            {
                int blackWins = 0;
                int totalGames = 5;

                for (int x = 0; x < totalGames; x++)
                {
                    int[,] tempNewBoard = new int[9, 9];
                    Array.Copy(curBoard, tempNewBoard, 9 * 9);
                    
                    if (SimulateRandomGame(curBlack, tempNewBoard, 0, ref blackCaps, ref whiteCaps) > 0) //Black wins
                    {
                        blackWins++;
                    }
                    //Ignore ties for now
                }

                return (double)blackWins / (double)totalGames;
            }
            static Random random = new Random();
            //Do everything recursively for now, to see speed-boost when it is not recursive
            //Returns score for black (so negative means loss)

            public static double SimulateRandomGame(bool curBlack, int[,] curBoard, int curBlackNetCapture, ref int blackCaps, ref int whiteCaps)
            {
                //Keep no meta-data for now, in the future we probably will

                int xPlace = random.Next(9);
                int yPlace = random.Next(9);

                int curPiece = curBlack ? 1 : 2;
                int oppositePiece = curBlack ? 2 : 1;

                bool emptySquare = false; //Make sure there is an empty square
                int emptySquares = 0;
                for (int x = 0; x < 9 && !emptySquare; x++)
                    for (int y = 0; y < 9 && !emptySquare; y++)
                    {
                        //Measure to detect if we should place a piece here, this is key as if this is very good we can
                        //end the analysis early, but if this is flawed all subsequent analysis will be flawed
                        if (curBoard[x, y] == 0)
                        {
                            if (ShouldEverPlacePieceHere(1, curBoard, x, y) || ShouldEverPlacePieceHere(2, curBoard, x, y))
                            {
                                emptySquare = true;
                                emptySquares++;
                                //break;
                            }
                            else
                            {
                            }
                        }
                    }

                //removeCaptures(curBoard, ref blackCaps, ref whiteCaps);

                if (emptySquares == 0)
                {
                    removeCaptures(curBoard, ref blackCaps, ref whiteCaps);

                    int blackTer, whiteTer;

                    territoryScore(curBoard, out blackTer, out whiteTer);

                    return (blackCaps - whiteCaps) * 2 + (blackTer - whiteTer) + komi; //2, as you cap it and get territory
                }

                //The check if it is good may be unneccessary and will likely be a large hotspot?
                while (curBoard[xPlace, yPlace] != 0 && !ShouldEverPlacePieceHere(curPiece, curBoard, xPlace, yPlace))
                {
                    xPlace = random.Next(9);
                    yPlace = random.Next(9);
                }

                curBoard[xPlace, yPlace] = -9;
                curBoard[xPlace, yPlace] = curPiece;

                int removed = 0;
                //A more efficient way to remove piece, only call remove if there are places
                //near the piece we placed that now have no liberties
                if (equals(xPlace, yPlace + 1, curBoard, oppositePiece))
                    if (liberties(xPlace, yPlace + 1, curBoard) == 0)
                        removed += removeGroup(curBoard, xPlace, yPlace + 1, oppositePiece, curPiece, 0);

                if (equals(xPlace, yPlace - 1, curBoard, oppositePiece))
                    if (liberties(xPlace, yPlace - 1, curBoard) == 0)
                        removed += removeGroup(curBoard, xPlace, yPlace - 1, oppositePiece, curPiece, 0);

                if (equals(xPlace + 1, yPlace, curBoard, oppositePiece))
                    if (liberties(xPlace + 1, yPlace, curBoard) == 0)
                        removed += removeGroup(curBoard, xPlace + 1, yPlace, oppositePiece, curPiece, 0);

                if (equals(xPlace - 1, yPlace, curBoard, oppositePiece))
                    if (liberties(xPlace - 1, yPlace, curBoard) == 0)
                        removed += removeGroup(curBoard, xPlace - 1, yPlace, oppositePiece, curPiece, 0);

                if (curPiece == 1)
                    blackCaps += removed;
                else
                    whiteCaps += removed;

                //Check if the place we placed will remove any pieces

                return SimulateRandomGame(!curBlack, curBoard, curBlackNetCapture, ref blackCaps, ref whiteCaps);
            }
            //This is a key fundamental partially heuristic function, if this works well everything else will work well        
            public static bool ShouldEverPlacePieceHere(int piece, int[,] curBoard, int x, int y)
            {
                int oppositePiece = piece == 1 ? 2 : 1;

                //Add up adjacent liberty groups
                int oneLib = 0, twoLib = 0, threeLib = 0, fourLib = 0;
                if (equals(x, y + 1, curBoard, piece))
                    oneLib = liberties(x, y + 1, curBoard) - 1; //Negative one, as we ignore our current spot
                if (equals(x, y - 1, curBoard, piece))
                    twoLib = liberties(x, y - 1, curBoard) - 1;
                if (equals(x + 1, y, curBoard, piece))
                    threeLib = liberties(x + 1, y, curBoard) - 1;
                if (equals(x - 1, y, curBoard, piece))
                    fourLib = liberties(x - 1, y, curBoard) - 1;

                int oneType = y + 1 < 9 ? curBoard[x, y + 1] : -2;
                int twoType = y - 1 >= 0 ? curBoard[x, y - 1] : -2;
                int threeType = x + 1 < 9 ? curBoard[x + 1, y] : -2;
                int fourType = x - 1 >= 0 ? curBoard[x - 1, y] : -2;

                //They were previously capped, either it is super secure for us, or death for us
                if (oneType <= -10 || twoType <= -10 || threeType <= -10 || fourType <= -10)
                    return false;

                //Of course if we just have an empty square beside us, this counts
                if (equals(x, y + 1, curBoard, 0))
                    oneLib = 1;
                if (equals(x, y - 1, curBoard, 0))
                    twoLib = 1;
                if (equals(x + 1, y, curBoard, 0))
                    threeLib = 1;
                if (equals(x - 1, y, curBoard, 0))
                    fourLib = 1;

                int sum = oneLib + twoLib + threeLib + fourLib;

                //Make sure we aren't suiciding, or putting ourself in a spot where we will die right away
                if (sum == 0 || sum == 1)
                {
                    //Check if placing will kill something else, then its okay
                    if (equals(x, y + 1, curBoard, oppositePiece) && liberties(x, y + 1, curBoard) == 1)
                        return true;
                    if (equals(x, y - 1, curBoard, oppositePiece) && liberties(x, y - 1, curBoard) == 1)
                        return true;
                    if (equals(x + 1, y, curBoard, oppositePiece) && liberties(x + 1, y, curBoard) == 1)
                        return true;
                    if (equals(x - 1, y, curBoard, oppositePiece) && liberties(x - 1, y, curBoard) == 1)
                        return true;

                    //Nothing to kill... so you it is really suicide
                    return false;
                }

                //If any places are in danger of being taken, we should save them
                if (oneLib == 0 || twoLib == 0 || threeLib == 0 || fourLib == 0)
                    return true;

                //Make sure we are not placing in places with no threats, and that we already have lots of pieces
                if (oneType != oppositePiece && twoType != oppositePiece && threeType != oppositePiece && fourType != oppositePiece) //No threats
                {
                    //This is not working, so lets be super aggressive... only place when you are next to an enemy
                    return false;

                    int neighbours = 0;
                    if (oneType == piece)
                        neighbours++;
                    if (twoType == piece)
                        neighbours++;
                    if (threeType == piece)
                        neighbours++;
                    if (fourType == piece)
                        neighbours++;

                    if (neighbours >= 3) //So many neighbours, so we have no need to place here (more aggressive moves are likely always better)
                        return false;
                }



                //We could also check for small areas we are secured with two eyes and the enemy cannot form two eyes in.
                return true;
            }


            public static double MonteCarloForBlackMetadata(bool curBlack, int[,] curBoard, int blackCaps, int whiteCaps)
            {
                int blackWins = 0;
                int totalGames = 5;

                for (int x = 0; x < totalGames; x++)
                {
                    int[,] tempNewBoard = new int[9, 9];
                    Array.Copy(curBoard, tempNewBoard, 9 * 9);

                    if (SimulateRandomGameWithMetadata(curBlack, tempNewBoard, 0, ref blackCaps, ref whiteCaps) > 0) //Black wins
                    {
                        blackWins++;
                    }
                    //Ignore ties for now
                }

                return (double)blackWins / (double)totalGames;
            }

            public static double SimulateRandomGameWithMetadata(bool curBlack, int[,] curBoard, int curBlackNetCapture, ref int blackCaps, ref int whiteCaps)
            {
                //Calculate liberty groups, then in the future we will just keep track of them instead of recalculating them
                int[,] libertyGroups = new int[9, 9]; //|v| = liberty group size, sgn(v) == +, means black, sgn(v) == - means white
                int[,] groupNumbers = new int[9,9]; //numbered starting at 1, unique number for every group with a max equal to curGroupCount
                int curGroupCount = 0;
                CreateLibertyGroups(curBoard, libertyGroups, groupNumbers, ref curGroupCount);

                return SimMetadataRecurse(curBlack, curBoard, libertyGroups, groupNumbers, ref curGroupCount, curBlackNetCapture, ref blackCaps, ref whiteCaps);                 
            }
            public static double SimMetadataRecurse(bool curBlack, int[,] curBoard, int[,] libertyGroups, int [,] groupNumbers, ref int curGroupCount, int curBlackNetCapture, ref int blackCaps, ref int whiteCaps)
            {                
                int curPiece = curBlack ? 1 : 2;
                int oppositePiece = curBlack ? 2 : 1;                

                bool emptySquare = false; //Make sure there is an empty square
                int emptySquares = 0;
                int blackSquaresToPlace = 0;
                int whiteSquaresToPlace = 0;
                for (int x = 0; x < 9 && !emptySquare; x++)
                    for (int y = 0; y < 9 && !emptySquare; y++)
                    {
                        //Measure to detect if we should place a piece here, this is key as if this is very good we can
                        //end the analysis early, but if this is flawed all subsequent analysis will be flawed
                        if (curBoard[x, y] == 0)
                        {
                            if (KeepBranch(1, curBoard, libertyGroups, groupNumbers, ref curGroupCount, x, y))
                            {
                                blackSquaresToPlace++;
                                if (KeepBranch(2, curBoard, libertyGroups, groupNumbers, ref curGroupCount, x, y))
                                {
                                    whiteSquaresToPlace++;

                                    //Strange branching in order to get to this place, but it was free! (sort of)                                
                                    emptySquares++;                                
                                }
                            }
                            else
                            {
                                if (KeepBranch(2, curBoard, libertyGroups, groupNumbers, ref curGroupCount, x, y))
                                    whiteSquaresToPlace++;                                
                            }                            
                        }
                    }

                //removeCaptures(curBoard, ref blackCaps, ref whiteCaps);

                if (emptySquares == 0) //No where to place for either side, so GAME IS OVER
                {
                    double finalScore = blackCaps - whiteCaps;
                    blackCaps = 0;
                    whiteCaps = 0;

                    removeCapturesFinal(curBoard, libertyGroups, groupNumbers, ref curGroupCount, ref blackCaps, ref whiteCaps);

                    finalScore += blackCaps - whiteCaps;

                    int blackTer, whiteTer;
                    territoryScore(curBoard, out blackTer, out whiteTer);

                    finalScore += blackTer - whiteTer;
                    finalScore += curBlackNetCapture;

                    finalScore += komi;

                    return finalScore;
                }

                //PASS
                if ((curBlack && blackSquaresToPlace == 0) || (!curBlack && whiteSquaresToPlace == 0))
                    return SimMetadataRecurse(!curBlack, curBoard, libertyGroups, groupNumbers, ref curGroupCount, curBlackNetCapture, ref blackCaps, ref whiteCaps);

                int xPlace = random.Next(9);
                int yPlace = random.Next(9);
                //The check if it is good may be unneccessary and will likely be a large hotspot?
                while (curBoard[xPlace, yPlace] != 0 || !KeepBranch(curPiece, curBoard, libertyGroups, groupNumbers, ref curGroupCount, xPlace, yPlace))
                {
                    xPlace = random.Next(9);
                    yPlace = random.Next(9);
                }

                //PLACE PIECE                
                MetaPlayPiece(curPiece, curBoard, libertyGroups, groupNumbers, ref curGroupCount, xPlace, yPlace, ref blackCaps, ref whiteCaps);

                for (int x = 0; x < 9 && !emptySquare; x++)
                    for (int y = 0; y < 9 && !emptySquare; y++)
                    {

                    }

                return SimMetadataRecurse(!curBlack, curBoard, libertyGroups, groupNumbers, ref curGroupCount, curBlackNetCapture, ref blackCaps, ref whiteCaps);
            }
            public static void tempemptylibcheck(int[,] curBoard, int[,] libertyGroups, int [,] groupNumbers, ref int curGroupCount)
            {
                for (int xp = 0; xp < 9; xp++)
                    for (int yp = 0; yp < 9; yp++)
                    {
                        if (curBoard[xp, yp] < int.MinValue + 100 && libertyGroups[xp, yp] != 0)
                        {
                        }
                    }
            }
            
            /// <summary>
            /// 0 means hard stop loop, 1 means skip loop and 2 means do loop normally
            /// </summary>            
            public int PlayLoop(ref int x, ref int y, ref int count)
            {
                switch (count)
                {
                    case 0:
                        x++;count++;
                        if (x < 9)
                            return 2;
                        else
                            return 1;
                    case 1:
                        x -= 2;count++;
                        if (x >= 0)
                            return 2;
                        else
                            return 1;
                    case 2:
                        x++;y++;count++;
                        if (y < 9)
                            return 2;
                        else
                            return 1;
                    case 3:
                        y -= 2;count++;
                        if (y >= 0)
                            return 2;
                        else
                            return 1;
                    default:
                        y++;count++;
                        return 0;
                }
            }
            //Keeping track of groups and then checking based on that may be faster than this
            //(this will screen multiple empties too, but usually that won't be a problem)
            public bool ScreenDuplicates(int x, int y, int count, int[,] groupNumbers)
            {
                switch (count)
                {                        
                    case 0:
                        return ((x - 2 < 0 || groupNumbers[x, y] != groupNumbers[x - 2, y]) &&
                            (y + 1 >= 9 || groupNumbers[x, y] != groupNumbers[x - 1, y + 1]) &&
                            (y - 1 < 0 || groupNumbers[x, y] != groupNumbers[x - 1, y - 1]));                            
                    case 1:
                        return ((y + 1 >= 9 || groupNumbers[x, y] != groupNumbers[x + 1, y + 1]) &&
                            (y - 1 < 0 || groupNumbers[x, y] != groupNumbers[x + 1, y - 1]));
                    case 2:
                        return (y - 2 < 0 || groupNumbers[x, y] != groupNumbers[x, y - 2]);
                    case 3:
                        return true;
                    default:
                        return true;
                }
            }
            public static void MetaPlayPiece(int curPiece, int[,] curBoard, int[,] libertyGroups, int [,] groupNumbers, ref int curGroupCount, int x, int y, ref int blackCaps, ref int whiteCaps)
            {
                int[,] originalBoardState2 = new int[9, 9];
                Array.Copy(curBoard, originalBoardState2, 9 * 9);

                int[,] originalBoardLib2 = new int[9, 9];
                Array.Copy(libertyGroups, originalBoardLib2, 9 * 9);

                int[,] originalBoardGroup2 = new int[9, 9];
                Array.Copy(groupNumbers, originalBoardGroup2, 9 * 9);
                 
                int ourSgn = curPiece == 1 ? 1 : -1;
                
                int oppositePiece = curPiece == 1 ? 2 : 1;
                                
                int caps = 0;
                int newGroupLiberties = 0;
                //Recalculate adjacent liberty groups

                curBoard[x, y] = -9; //Just for debugging, that way I can visually see where we are placing a piece
                //curBoard[x, y] = curPiece;

                //The adjacent groups which needs to be combined
                int[] xGroups = { -1, -1, -1, -1 };
                int[] yGroups = { -1, -1, -1, -1 };
                int curCombineGroups = 0;

                int emptySurrounding = 0;

                KeepBranch(curPiece, curBoard, libertyGroups, groupNumbers, ref curGroupCount, x, y);

                int count = 0;

                //Remove enemy liberties and kill enemy groups (recalculating affected liberties)                
                x++;
                if (x < 9)
                {                       
                    if (libertyGroups[x, y] * ourSgn == -1) //It has no more liberties and so it dies now
                    {
                        int takenPiece = curBoard[x, y] == 1 ? int.MinValue + 1 : int.MinValue;

                        //Remove other group
                        caps += removeGroupMeta(curBoard, libertyGroups, groupNumbers, ref curGroupCount, x, y, oppositePiece, curPiece, takenPiece);
                        emptySurrounding++; //Now there is an empty here
                    }
                    else if (libertyGroups[x, y] * ourSgn < 0) //We just decrement its number of liberties, unless of course it borders us more than once
                    {
                        //If 1 overlaps anything, don't add it (the last one will add it)
                        // 1-2 ... 1-3 ... 1-4
                        if ((x - 2 < 0 || groupNumbers[x, y] != groupNumbers[x - 2, y]) &&
                            (y + 1 >= 9 || groupNumbers[x, y] != groupNumbers[x - 1, y + 1]) &&
                            (y - 1 < 0 || groupNumbers[x, y] != groupNumbers[x - 1, y - 1]))
                            SetGroupNumber(libertyGroups, x, y, libertyGroups[x, y] + ourSgn, libertyGroups[x, y]);
                    }
                    else if (libertyGroups[x, y] * ourSgn > 0) //Add it to our new liberty grouping
                    {
                        xGroups[curCombineGroups] = x;
                        yGroups[curCombineGroups] = y;
                        curCombineGroups++;
                    }
                    else
                    {
                        emptySurrounding++;
                    }
                }
                x -= 2;
                if (x >= 0)
                {
                    if (libertyGroups[x, y] * ourSgn == -1) //It has no more liberties and so it dies now
                    {
                        int takenPiece = curBoard[x, y] == 1 ? int.MinValue + 1 : int.MinValue;

                        //Remove other group
                        caps += removeGroupMeta(curBoard, libertyGroups, groupNumbers, ref curGroupCount, x, y, oppositePiece, curPiece, takenPiece);
                        emptySurrounding++; //Now there is an empty here
                    }
                    else if (libertyGroups[x, y] * ourSgn < 0) //We just decrement its number of liberties, unless of course it borders us more than once
                    {                                                      
                        //If 2 overlaps anything less, don't add it (the last one will add it)
                        // 2-3, 2-4
                        if ((y + 1 >= 9 || groupNumbers[x, y] != groupNumbers[x + 1, y + 1]) &&
                            (y - 1 < 0 || groupNumbers[x, y] != groupNumbers[x + 1, y - 1]))                                                   
                            SetGroupNumber(libertyGroups, x, y, libertyGroups[x, y] + ourSgn, libertyGroups[x, y]);                    
                    }
                    else if(libertyGroups[x, y] * ourSgn > 0) //Add it to our new liberty grouping
                    {
                        bool overlap = false;
                        //We do an inverted check, see if we have already done it, instead of if we will
                        for (int b = 0; b < curCombineGroups; b++)  //I think this might actually be faster than checking for overlaps                        
                            if (groupNumbers[xGroups[b], yGroups[b]] == groupNumbers[x, y])
                                overlap = true;

                        if (!overlap)
                        {
                            xGroups[curCombineGroups] = x;
                            yGroups[curCombineGroups] = y;
                            curCombineGroups++;
                        }
                    }
                    else
                    {
                        emptySurrounding++;
                    }
                }
                x++; y++;
                if (y < 9)
                {
                    if (libertyGroups[x, y] * ourSgn == -1) //It has no more liberties and so it dies now
                    {
                        int takenPiece = curBoard[x, y] == 1 ? int.MinValue + 1 : int.MinValue;

                        //Remove other group
                        caps += removeGroupMeta(curBoard, libertyGroups, groupNumbers, ref curGroupCount, x, y, oppositePiece, curPiece, takenPiece);
                        emptySurrounding++; //Now there is an empty here
                    }
                    else if (libertyGroups[x, y] * ourSgn < 0) //We just decrement its number of liberties, unless of course it borders us more than once
                    {
                        //If 3 overlaps anything less, don't add it (the last one will add it)
                        // 3-4
                        if (y - 2 < 0 || groupNumbers[x, y] != groupNumbers[x, y - 2])
                            SetGroupNumber(libertyGroups, x, y, libertyGroups[x, y] + ourSgn, libertyGroups[x, y]);
                    }
                    else if (libertyGroups[x, y] * ourSgn > 0) //Add it to our new liberty grouping
                    {
                        bool overlap = false;
                        //We do an inverted check, see if we have already done it, instead of if we will
                        for (int b = 0; b < curCombineGroups; b++)  //I think this might actually be faster than checking for overlaps                        
                            if (groupNumbers[xGroups[b], yGroups[b]] == groupNumbers[x, y])
                                overlap = true;

                        if (!overlap)
                        {
                            xGroups[curCombineGroups] = x;
                            yGroups[curCombineGroups] = y;
                            curCombineGroups++;
                        }
                    }
                    else
                    {
                        emptySurrounding++;
                    }
                }
                y -= 2;
                if (y >= 0)
                {
                    if (libertyGroups[x, y] * ourSgn == -1) //It has no more liberties and so it dies now
                    {
                        int takenPiece = curBoard[x, y] == 1 ? int.MinValue + 1 : int.MinValue;

                        //Remove other group
                        caps += removeGroupMeta(curBoard, libertyGroups, groupNumbers, ref curGroupCount, x, y, oppositePiece, curPiece, takenPiece);
                        emptySurrounding++; //Now there is an empty here
                    }
                    else if (libertyGroups[x, y] * ourSgn < 0) //We just decrement its number of liberties, unless of course it borders us more than once
                    {
                        //No need to check for overlap, we are last one                                                 
                        SetGroupNumber(libertyGroups, x, y, libertyGroups[x, y] + ourSgn, libertyGroups[x, y]);
                    }
                    else if(libertyGroups[x, y] * ourSgn > 0) //Add it to our new liberty grouping
                    {
                        bool overlap = false;
                        //We do an inverted check, see if we have already done it, instead of if we will
                        for (int b = 0; b < curCombineGroups; b++)  //I think this might actually be faster than checking for overlaps                        
                            if (groupNumbers[xGroups[b], yGroups[b]] == groupNumbers[x, y])
                                overlap = true;

                        if (!overlap)
                        {
                            xGroups[curCombineGroups] = x;
                            yGroups[curCombineGroups] = y;
                            curCombineGroups++;
                        }
                    }
                    else
                    {
                        emptySurrounding++;
                    }
                }
                y++;

                
                //Take all of the groups and combine them, now that they liberties are correct as removed groups have been accounted for
                for (int b = 0; b < curCombineGroups; b++)
                    newGroupLiberties += libertyGroups[xGroups[b], yGroups[b]];

                newGroupLiberties -= curCombineGroups * ourSgn; //Subtract as we are losing 1 liberty per group we touch
                newGroupLiberties += emptySurrounding * ourSgn;

                //CRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP
                //We might ALSO SHARE A LIBERTY WITH THE EXISTING GROUPS! You have to check for this to!

                curGroupCount++;
                int newGroupNumber = curGroupCount;
                //Now, we combine all of the libertyGroups
                libertyGroups[x, y] = newGroupLiberties;
                groupNumbers[x, y] = newGroupNumber;
                //curBoard[x, y] = curPiece; (done later now, for debugging purposes)
                for (int b = 0; b < curCombineGroups; b++)
                {
                    if (newGroupLiberties != libertyGroups[xGroups[b], yGroups[b]]) //It is entirely possible to place beside a group, and not change its liberties
                        SetGroupNumber(libertyGroups, xGroups[b], yGroups[b], newGroupLiberties, libertyGroups[xGroups[b], yGroups[b]]);
                    SetGroupNumber(groupNumbers, xGroups[b], yGroups[b], newGroupNumber, groupNumbers[xGroups[b], yGroups[b]]);
                }

                if ((newGroupLiberties == 0 || newGroupLiberties == 1) && caps == 0) //Uh... that was a dumb move?
                {
                    int temp = 0;
                    CreateLibertyGroups(curBoard, libertyGroups, curBoard, ref temp);
                    //Actually... this will be triggered when we cap a move, but are then in a bad place
                    curBoard[x, y] = 0;

                    KeepBranch(curPiece, curBoard, libertyGroups, groupNumbers, ref curGroupCount, x, y);

                    showboard(curBoard);
                    //MetaPlayPiece(curPiece, originalBoardState, originalBoardLib, originalBoardGroup, ref curGroupCount, x, y, ref blackCaps, ref whiteCaps);
                    KeepBranch(curPiece, curBoard, libertyGroups, groupNumbers, ref curGroupCount, x, y);
                }

                curBoard[x, y] = curPiece;

                tempemptylibcheck(curBoard, libertyGroups, groupNumbers, ref curGroupCount);
                //MetaPlayPiece(curPiece, originalBoardState, originalBoardLib, originalBoardGroup, ref curGroupCount, x, y, ref blackCaps, ref whiteCaps);

                if (curPiece == 1)
                    blackCaps += caps;
                else
                    whiteCaps += caps;



                int[,] originalBoardState = new int[9, 9];
                Array.Copy(curBoard, originalBoardState, 9 * 9);

                int[,] originalBoardLib = new int[9, 9];
                Array.Copy(libertyGroups, originalBoardLib, 9 * 9);

                int[,] originalBoardGroup = new int[9, 9];
                Array.Copy(groupNumbers, originalBoardGroup, 9 * 9);               

                //MetaPlayPiece(curPiece, originalBoardState, originalBoardLib, originalBoardGroup, ref curGroupCount, x, y, ref blackCaps, ref whiteCaps);

                int groupCount = 0;
                CreateLibertyGroups(originalBoardState, originalBoardLib, originalBoardGroup, ref groupCount);

                for (int xp = 0; xp < 9; xp++)
                    for (int yp = 0; yp < 9; yp++)
                    {
                        if (libertyGroups[xp, yp] != originalBoardLib[xp, yp]) //Not good, our liberty groups are wrong
                        {
                            MetaPlayPiece(curPiece, originalBoardState2, originalBoardLib2, originalBoardGroup2, ref curGroupCount, x, y, ref blackCaps, ref whiteCaps);
                            curBoard[x, y] = 9;
                        }
                    }
            }

            public static bool KeepBranch(int piece, int[,] curBoard, int[,] libertyGroups, int [,] groupNumbers, ref int curGroupCount, int x, int y)
            {
                int oppositePiece = piece == 1 ? 2 : 1;
                int ourSgn = piece == 1 ? 1 : -1;
                
                //Add up adjacent liberty groups
                int oneLib = 0, twoLib = 0, threeLib = 0, fourLib = 0;

                if (x + 1 < 9)
                    oneLib = libertyGroups[x + 1, y] * ourSgn;

                if (x - 1 >= 0)
                    twoLib = libertyGroups[x - 1, y] * ourSgn;

                if (y + 1 < 9)
                    threeLib = libertyGroups[x, y + 1] * ourSgn;

                if (y - 1 >= 0)
                    fourLib = libertyGroups[x, y - 1] * ourSgn;
                
                //They were previously capped, either it is super secure for us, or death for us
                if (curBoard[x, y] <= -1000 || curBoard[x, y] <= -1000 || curBoard[x, y] <= -1000 || curBoard[x, y] <= -1000)
                    return false;

                int sum = 0;
                //Of course if we just have an empty square beside us, this counts
                if (x + 1 < 9 && (libertyGroups[x + 1, y] == 0 || libertyGroups[x + 1, y] < (int.MinValue + 100)))
                    sum++;
                if (x - 1 >= 0 && (libertyGroups[x - 1, y] == 0 || libertyGroups[x - 1, y] < (int.MinValue + 100)))
                    sum++;
                if (y + 1 < 9 && (libertyGroups[x, y + 1] == 0 || libertyGroups[x, y + 1] < (int.MinValue + 100)))
                    sum++;
                if (y - 1 >= 0 && (libertyGroups[x, y - 1] == 0 || libertyGroups[x, y - 1] < (int.MinValue + 100)))
                    sum++;
                
                if(oneLib > 1) //>1, as 1 means we are the only liberty they have
                    sum += oneLib - 1;
                if (twoLib > 1)
                    sum += twoLib - 1;
                if (threeLib > 1)
                    sum += threeLib - 1;
                if (fourLib > 1)
                    sum += fourLib - 1;

                //Make sure we aren't suiciding, or putting ourself in a spot where we will die right away
                if (sum == 0 || sum == 1) //0 is suicide, 1 means they will play and kill us (sometimes GOOD, but for now IGNORE this case)
                {
                    //Check if placing will kill something else, then its okay
                    if (oneLib == -1)
                        return true;
                    if (twoLib == -1)
                        return true;
                    if (threeLib == -1)
                        return true;
                    if (fourLib == -1)
                        return true;

                    //Nothing to kill... so it is really suicide
                    return false;
                }

                //If any places are in danger of being taken, we should save them (and of course we know it is not suicide, because of the above)
                if (oneLib == 1 || twoLib == 1 || threeLib == 1 || fourLib == 1)
                    return true;

                //Make sure we are not placing in places with no threats, and that we already have lots of pieces
                if (oneLib >= 0 && twoLib >= 0 && threeLib >= 0 && fourLib >= 0) //No threats
                {
                    //This is not working, so lets be super aggressive... only place when you are next to an enemy
                    //return false;

                    int neighbours = 0;
                    if (oneLib > 0)
                        neighbours++;
                    if (twoLib > 0)
                        neighbours++;
                    if (threeLib > 0)
                        neighbours++;
                    if (fourLib > 0)
                        neighbours++;

                    if (neighbours >= 3) //So many neighbours, so we have no need to place here (more aggressive moves are likely always better)
                        return false;
                }

                //We could also check for small areas we are secured with two eyes and the enemy cannot form two eyes in.
                return true;
            }

            public static void removeCapturesFinal(int[,] curBoard, int[,] libertyGroups, int[,] groupNumbers, ref int curGroupCount, ref int blackCaptured, ref int whiteCaptured)
            {
                for (int x = 0; x < 9; x++)
                    for (int y = 0; y < 9; y++)
                        if (curBoard[x, y] > 0)
                        {
                            if (libertyGroups[x, y] == 0)
                            {
                                if (curBoard[x, y] == 1)
                                    blackCaptured++;
                                else
                                    whiteCaptured++;

                                int takenPiece = curBoard[x, y] == 1 ? int.MinValue + 1 : int.MinValue;

                                curBoard[x, y] = takenPiece; //Mark it so we never place there again
                            }
                        }
            }

            //ATTENTION! I am not sure which of finding the liberty groups by following the empty squares and adding to places around them,
            //or following groups and adding the empty squares around them is faster, test both?

            //|v| = liberty group size, sgn(v) == +, means black, sgn(v) == - means white
            //Creates from just a basic board, with 0 for empty, 1 for black and 2 for white (no other pieces). libertyGroups is just overwritten right away too

            //removes special marked empty squares and just makes them empty
            public static void CreateLibertyGroups(int[,] curBoard, int[,] libertyGroups, int [,] groupNumbers, ref int curGroupCount)
            { 
                Array.Copy(curBoard, libertyGroups, 9 * 9);
                Array.Copy(curBoard, groupNumbers, 9 * 9);                                

                for(int x = 0 ; x < 9; x++)
                    for (int y = 0; y < 9; y++)
                    {
                        //libertyGroups[x, y] = 0;
                        //groupNumbers[x, y] = 0;
                        if (curBoard[x, y] == 1 || curBoard[x, y] == 2)
                        {
                            curGroupCount++;
                            SetGroupNumber(libertyGroups, x, y, -(curGroupCount), libertyGroups[x, y]);
                            SetGroupNumber(groupNumbers, x, y, -(curGroupCount), groupNumbers[x, y]);
                        }
                        else if (groupNumbers[x, y] < int.MinValue + 100)
                        {
                            curBoard[x, y] = 0;
                            libertyGroups[x, y] = 0;
                            groupNumbers[x, y] = 0;
                        }
                    }

                int[] libertyCounts = new int[curGroupCount];

                for(int x = 0 ; x < 9; x++)
                    for (int y = 0; y < 9; y++)
                        if (libertyGroups[x, y] == 0 || libertyGroups[x, y] < int.MinValue + 100) //Every empty square adds liberties to the groups around it   
                        {
                            //OOPS, we can border one group multiple times, so... lets fix that here

                            //    4
                            //   2x1
                            //    3

                            if (x + 1 < 9 && groupNumbers[x + 1, y] != 0)
                            {                                
                                //If 1 overlaps anything, don't add it (the last one will add it)
                                // 1-2 ... 1-3 ... 1-4
                                if ((x - 1 < 0 || groupNumbers[x + 1, y] != groupNumbers[x - 1, y]) &&
                                    (y + 1 >= 9 || groupNumbers[x + 1, y] != groupNumbers[x, y + 1]) &&
                                    (y - 1 < 0 || groupNumbers[x + 1, y] != groupNumbers[x, y - 1]))
                                    libertyCounts[-groupNumbers[x + 1, y] - 1]++;
                            }

                            if (x - 1 >= 0 && groupNumbers[x - 1, y] != 0)
                            {
                                if ((y + 1 >= 9 || groupNumbers[x - 1, y] != groupNumbers[x, y + 1]) &&
                                    (y - 1 < 0 || groupNumbers[x - 1, y] != groupNumbers[x, y - 1]))
                                    libertyCounts[-groupNumbers[x - 1, y] - 1]++;
                            }

                            if (y + 1 < 9 && groupNumbers[x, y + 1] != 0)
                            {
                                if (y - 1 < 0 || groupNumbers[x, y + 1] != groupNumbers[x, y - 1])
                                    libertyCounts[-groupNumbers[x, y + 1] - 1]++;
                            }

                            if (y - 1 >= 0 && groupNumbers[x, y - 1] != 0)
                                libertyCounts[-groupNumbers[x, y - 1] - 1]++;                            
                        }

                //Renumber groups, 
                for(int x = 0 ; x < 9; x++)
                    for (int y = 0; y < 9; y++)
                        if (groupNumbers[x, y] < 0) //It is still numbered, not with a count
                        {
                            groupNumbers[x, y] = -groupNumbers[x, y];

                            int sgn = curBoard[x, y] == 1 ? 1 : -1;
                            int libGroupNum = groupNumbers[x, y] - 1;
                            if(libertyCounts[libGroupNum] * sgn != libertyGroups[x, y]) //Our count may just happen to equal our previous group number
                                SetGroupNumber(libertyGroups, x, y, libertyCounts[libGroupNum] * sgn, libertyGroups[x, y]);                            
                        }                     
            }
            //Numbers them, but with negative numbers
            public static void SetGroupNumber(int[,] libertyGroups, int curX, int curY, int newNumber, int colorToNumber)
            {
                if (newNumber == colorToNumber)
                    throw new Exception("you cannot replace something with itself, there is an error in the calling code.");
                
                libertyGroups[curX, curY] = newNumber;

                if (curX + 1 < 9 && libertyGroups[curX + 1, curY] == colorToNumber)
                    SetGroupNumber(libertyGroups, curX + 1, curY, newNumber, colorToNumber );
                if (curX - 1 >= 0 && libertyGroups[curX - 1, curY] == colorToNumber)
                    SetGroupNumber(libertyGroups, curX - 1, curY, newNumber, colorToNumber );
                if (curY + 1 < 9 && libertyGroups[curX, curY + 1] == colorToNumber)
                    SetGroupNumber(libertyGroups, curX, curY + 1, newNumber, colorToNumber );
                if (curY - 1 >= 0 && libertyGroups[curX, curY - 1] == colorToNumber)
                    SetGroupNumber(libertyGroups, curX, curY - 1, newNumber, colorToNumber );
            }

            public static void SetGroupNumberFromOther(int[,] valueToSet, int[,] valuesToFollow, int curX, int curY, int newValue, int valueToFollow, int newValueToFollow)
            {
                valueToSet[curX, curY] = newValue;
                valuesToFollow[curX, curY] = newValueToFollow;

                if (curX + 1 < 9 && valuesToFollow[curX + 1, curY] == valueToFollow)
                    SetGroupNumberFromOther(valueToSet, valuesToFollow, curX + 1, curY, newValue, valueToFollow, newValueToFollow);
                if (curX - 1 >= 0 && valuesToFollow[curX - 1, curY] == valueToFollow)
                    SetGroupNumberFromOther(valueToSet, valuesToFollow, curX - 1, curY, newValue, valueToFollow, newValueToFollow);
                if (curY + 1 < 9 && valuesToFollow[curX, curY + 1] == valueToFollow)
                    SetGroupNumberFromOther(valueToSet, valuesToFollow, curX, curY + 1, newValue, valueToFollow, newValueToFollow);
                if (curY - 1 >= 0 && valuesToFollow[curX, curY - 1] == valueToFollow)
                    SetGroupNumberFromOther(valueToSet, valuesToFollow, curX, curY - 1, newValue, valueToFollow, newValueToFollow);
            }
            
            public static int removeGroupMeta(int[,] curBoard, int[,] libertyGroups, int [,] groupNumbers, ref int curGroupCount, int x, int y, int curPiece, int oppositePiece, int newPiece)
            {                
                int[] groupsAdjacent = new int[9 * 9 + 1]; //We can actually find the max, and it will likely be a lot lower than this, but for now this works
                int[] numberAdjacent = new int[9 * 9 + 1];
                int[] xStart = new int[9 * 9 + 1];
                int[] yStart = new int[9 * 9 + 1];

                for(int a = 0; a < 9 * 9 + 1; a++)
                {
                    groupsAdjacent[a] = 0;
                    numberAdjacent[a] = 0;
                    xStart[a] = 0;
                    yStart[a] = 0;
                }

                int amountRemoved = removeGroupMetaRecurs(curBoard, libertyGroups,groupNumbers, x, y, curPiece, oppositePiece, newPiece, 0,
                    groupsAdjacent, numberAdjacent, xStart, yStart);

                //Now add the extra liberties to the groups affected
                int pieceSgn = oppositePiece == 1 ? 1 : -1;

                int pos = 0;                
                while (groupsAdjacent[pos] != 0)
                {
                    curGroupCount++;
                    SetGroupNumberFromOther(libertyGroups, groupNumbers, xStart[pos], yStart[pos], pieceSgn * numberAdjacent[pos] +
                        libertyGroups[xStart[pos], yStart[pos]], groupNumbers[xStart[pos], yStart[pos]], curGroupCount);
                    pos++;
                }

                return amountRemoved;
            }

            public static int removeGroupMetaRecurs(int[,] curBoard, int[,] libertyGroups,int [,] groupNumbers, int x, int y, int curPiece, int oppositePiece, int newPiece, int curCount,
                int[] groupsAdjacent, int[] numberAdjacent, int[] xStart, int[] yStart)
            {
                //Remove piece
                curBoard[x, y] = newPiece;
                libertyGroups[x, y] = 0; //IMPORTANT! If you forget this it appears to group still exists!
                groupNumbers[x, y] = 0;
                curCount++;

                //tempemptylibcheck(curBoard, libertyGroups);

                //See if there are any new groups around us, and if there is then we should keep track of them
                //(all groups around us are of oppositePiece, of course!)
                x++;
                if (x < 9)
                {
                    if (curBoard[x, y] == oppositePiece)
                    {
                        int pos = 0;
                        while (groupsAdjacent[pos] != 0)
                        {
                            if (groupNumbers[x, y] == groupsAdjacent[pos]) //We already have the group                                                                                
                                break;
                            pos++;
                        }

                        //Either we found it, or are on a open group space
                        groupsAdjacent[pos] = groupNumbers[x, y];
                        numberAdjacent[pos]++;
                        xStart[pos] = x;
                        yStart[pos] = y;
                    }
                    else if (curBoard[x, y] == curPiece)
                    {
                        curCount += removeGroupMetaRecurs(curBoard, libertyGroups, groupNumbers, x, y, curPiece, oppositePiece, newPiece, curCount,
                    groupsAdjacent, numberAdjacent, xStart, yStart);
                    }
                }
                x -= 2;
                if (x >= 0)
                {
                    if (curBoard[x, y] == oppositePiece)
                    {
                        int pos = 0;
                        while (groupsAdjacent[pos] != 0)
                        {
                            if (groupNumbers[x, y] == groupsAdjacent[pos]) //We already have the group                                                                                
                                break;
                            pos++;
                        }

                        //Either we found it, or are on a open group space
                        groupsAdjacent[pos] = groupNumbers[x, y];
                        numberAdjacent[pos]++;
                        xStart[pos] = x;
                        yStart[pos] = y;
                    }
                    else if (curBoard[x, y] == curPiece)
                    {
                        curCount += removeGroupMetaRecurs(curBoard, libertyGroups, groupNumbers, x, y, curPiece, oppositePiece, newPiece, curCount,
                    groupsAdjacent, numberAdjacent, xStart, yStart);
                    }
                }
                x++; y++;
                if (y < 9)
                {
                    if (curBoard[x, y] == oppositePiece)
                    {
                        int pos = 0;
                        while (groupsAdjacent[pos] != 0)
                        {
                            if (groupNumbers[x, y] == groupsAdjacent[pos]) //We already have the group                                                                                
                                break;
                            pos++;
                        }

                        //Either we found it, or are on a open group space
                        groupsAdjacent[pos] = groupNumbers[x, y];
                        numberAdjacent[pos]++;
                        xStart[pos] = x;
                        yStart[pos] = y;
                    }
                    else if (curBoard[x, y] == curPiece)
                    {
                        curCount += removeGroupMetaRecurs(curBoard, libertyGroups, groupNumbers, x, y, curPiece, oppositePiece, newPiece, curCount,
                    groupsAdjacent, numberAdjacent, xStart, yStart);
                    }
                }
                y -= 2;
                if (y >= 0)
                {
                    if (curBoard[x, y] == oppositePiece)
                    {
                        int pos = 0;
                        while (groupsAdjacent[pos] != 0)
                        {
                            if (groupNumbers[x, y] == groupsAdjacent[pos]) //We already have the group                                                                                
                                break;
                            pos++;
                        }

                        //Either we found it, or are on a open group space
                        groupsAdjacent[pos] = groupNumbers[x, y];
                        numberAdjacent[pos]++;
                        xStart[pos] = x;
                        yStart[pos] = y;
                    }
                    else if (curBoard[x, y] == curPiece)
                    {
                        curCount += removeGroupMetaRecurs(curBoard, libertyGroups, groupNumbers, x, y, curPiece, oppositePiece, newPiece, curCount,
                    groupsAdjacent, numberAdjacent, xStart, yStart);
                    }
                }
                y++;

                return curCount;
            }


            public static void removeCaptures(int[,] curBoard, ref int blackCaptured, ref int whiteCaptured)
            {
                for (int x = 0; x < 9; x++)
                    for (int y = 0; y < 9; y++)
                        if (curBoard[x, y] > 0)
                        {
                            if (liberties(x, y, curBoard) == 0)
                            {
                                if (curBoard[x, y] == 1)
                                    blackCaptured++;
                                else
                                    whiteCaptured++;

                                int opposite = curBoard[x, y] == 1 ? 2 : 1;

                                curBoard[x, y] = -10 * opposite; //Mark it so we never place there again
                            }
                        }
            }

            //Returns size of group
            public static int removeGroup(int[,] curBoard, int x, int y, int curPiece, int oppositePiece, int curCount)
            {
                curBoard[x, y] = oppositePiece * -10;
                curCount++;

                if (equals(x, y + 1, curBoard, curPiece))
                    curCount += removeGroup(curBoard, x, y + 1, curPiece, oppositePiece, curCount);
                if (equals(x, y - 1, curBoard, curPiece))
                    curCount += removeGroup(curBoard, x, y - 1, curPiece, oppositePiece, curCount);
                if (equals(x + 1, y, curBoard, curPiece))
                    curCount += removeGroup(curBoard, x + 1, y, curPiece, oppositePiece, curCount);
                if (equals(x - 1, y, curBoard, curPiece))
                    curCount += removeGroup(curBoard, x - 1, y, curPiece, oppositePiece, curCount);

                return curCount;
            }

            public static bool equals(int x, int y, int[,] curBoard, int other)
            {
                if (x < 0 || y < 0 || x >= 9 || y >= 9)
                    return false;

                return curBoard[x, y] == other;
            }

            //PROBLEM, I don't think this actually accurate finds the number of liberties, and I think it duplicates liberties when a group borders
            //an open space multiple times!

            //Accurately finds the number of liberties, as standardly defined (not always useful liberties, but its something)
            public static int liberties(int x, int y, int[,] curBoard)
            {
                return recurseLibertiesBase(x, y, curBoard);
            }
            //For now, we do it recursively... but if we put it on the GPU it will likely be faster to do it non-recursively...
            //as it might be faster to use a fixed amount of memory if it is all on shared memory cache (maybe?)
            /*
        {
            int curLiberties = 0;

            int[,] tempNewBoard = new int[9, 9];
            Array.Copy(curBoard, tempNewBoard, 9 * 9);

            int[,] territoryQueue = new int[9 * 9, 3];
            int startQueue = 0;
            int endQueue = 0;

            addToQueue(x, y, curBoard[x, y], ref endQueue, territoryQueue);

            while (startQueue != endQueue)
            {
                //all curBoard[x,y] are the same anyway (as we are following a group), so we just dump it in there
                removeFromQueue(ref startQueue, territoryQueue, out curBoard[x, y], out x, out y);
                tempNewBoard[x, y] = -2; //Mark it so we don't revisit it


                //Mark all surrounding liberties
                if (equals(x, y + 1, tempNewBoard, 0)) {
                    curLiberties++; tempNewBoard[x, y+1] = -1;}
                if (equals(x, y - 1, tempNewBoard, 0)) {
                    curLiberties++; tempNewBoard[x, y-1] = -1;}
                if (equals(x + 1, y, tempNewBoard, 0)) {
                    curLiberties++; tempNewBoard[x+1, y] = -1;}
                if (equals(x - 1, y, tempNewBoard, 0)) {
                    curLiberties++; tempNewBoard[x-1, y] = -1;}

                //Follow liberty group
                if (equals(x, y + 1, tempNewBoard, curBoard[x, y]))
                    addToQueue(x, y+1, curBoard[x, y], ref endQueue, territoryQueue);
                if (equals(x, y - 1, tempNewBoard, curBoard[x, y]))
                    addToQueue(x, y-1, curBoard[x, y], ref endQueue, territoryQueue);
                if (equals(x + 1, y, tempNewBoard, curBoard[x, y]))
                    addToQueue(x+1, y, curBoard[x, y], ref endQueue, territoryQueue);
                if (equals(x - 1, y, tempNewBoard, curBoard[x, y]))
                    addToQueue(x-1, y, curBoard[x, y], ref endQueue, territoryQueue);
            }

            return curLiberties;
        }
        */

            public static int recurseLibertiesBase(int x, int y, int[,] curBoard)
            {
                int[,] tempNewBoard = new int[9, 9];
                Array.Copy(curBoard, tempNewBoard, 9 * 9);

                int curLiberties = 0;
                recurseLiberties(x, y, tempNewBoard, ref curLiberties);
                return curLiberties;
            }
            public static void recurseLiberties(int x, int y, int[,] curBoard, ref int curLiberties)
            {
                int curPiece = curBoard[x, y];
                int curOtherEmpty = curPiece * -10;

                //Mark all liberties and count them
                if (equals(x, y + 1, curBoard, 0) || equals(x, y + 1, curBoard, curOtherEmpty))
                {
                    curBoard[x, y + 1] = -1; curLiberties++;
                }
                if (equals(x, y - 1, curBoard, 0) || equals(x, y - 1, curBoard, curOtherEmpty))
                {
                    curBoard[x, y - 1] = -1; curLiberties++;
                }
                if (equals(x + 1, y, curBoard, 0) || equals(x + 1, y, curBoard, curOtherEmpty))
                {
                    curBoard[x + 1, y] = -1; curLiberties++;
                }
                if (equals(x - 1, y, curBoard, 0) || equals(x - 1, y, curBoard, curOtherEmpty))
                {
                    curBoard[x - 1, y] = -1; curLiberties++;
                }

                curBoard[x, y] *= -1;
                if (equals(x, y + 1, curBoard, curPiece))
                    recurseLiberties(x, y + 1, curBoard, ref curLiberties);
                if (equals(x, y - 1, curBoard, curPiece))
                    recurseLiberties(x, y - 1, curBoard, ref curLiberties);
                if (equals(x + 1, y, curBoard, curPiece))
                    recurseLiberties(x + 1, y, curBoard, ref curLiberties);
                if (equals(x - 1, y, curBoard, curPiece))
                    recurseLiberties(x - 1, y, curBoard, ref curLiberties);
            }


            public static int surroundingLiberties(int x, int y, int[,] curBoard, int pieceToCount)
            {
                int curLibCount = 0;

                if (equals(x, y + 1, curBoard, pieceToCount))
                    curLibCount += liberties(x, y + 1, curBoard);
                if (equals(x, y - 1, curBoard, pieceToCount))
                    curLibCount += liberties(x, y - 1, curBoard);
                if (equals(x + 1, y, curBoard, pieceToCount))
                    curLibCount += liberties(x + 1, y, curBoard);
                if (equals(x - 1, y, curBoard, pieceToCount))
                    curLibCount += liberties(x - 1, y, curBoard);

                return curLibCount;
            }


            //Marks the dead by making them negative
            public static void markDead(int[,] curBoard)
            {

            }


            //Should only be called when the board is entirely settled, there is a balance though
            //if this is more powerful less simulate needs to be done, but then also this takes longer        
            public static void territoryScore(int[,] curBoard, out int blackTerCount, out int whiteTerCount)
            {
                //For now this is super simple, assume that all territory that is owned is entirely surrounded
                int[,] tempNewBoard = new int[9, 9];
                Array.Copy(curBoard, tempNewBoard, 9 * 9);

                //-1 means black territory, -2 means white territory          

                int[,] territoryQueue = new int[9 * 9, 3];
                int startQueue = 0;
                int endQueue = 0;

                blackTerCount = 0;
                whiteTerCount = 0;

                int x, y;

                for (x = 0; x < 9; x++)
                    for (y = 0; y < 9; y++)
                        if (tempNewBoard[x, y] > 0)
                        {                                                  
                            splitToQueue(x, y + 1, tempNewBoard, ref endQueue, territoryQueue, -tempNewBoard[x, y], ref blackTerCount, ref whiteTerCount);
                            splitToQueue(x, y - 1, tempNewBoard, ref endQueue, territoryQueue, -tempNewBoard[x, y], ref blackTerCount, ref whiteTerCount);
                            splitToQueue(x + 1, y, tempNewBoard, ref endQueue, territoryQueue, -tempNewBoard[x, y], ref blackTerCount, ref whiteTerCount);
                            splitToQueue(x - 1, y, tempNewBoard, ref endQueue, territoryQueue, -tempNewBoard[x, y], ref blackTerCount, ref whiteTerCount);
                        }

                while (startQueue != endQueue)
                {
                    int pieceValue;
                    removeFromQueue(ref startQueue, territoryQueue, out pieceValue, out x, out y);

                    splitToQueue(x, y + 1, tempNewBoard, ref endQueue, territoryQueue, pieceValue, ref blackTerCount, ref whiteTerCount);
                    splitToQueue(x, y - 1, tempNewBoard, ref endQueue, territoryQueue, pieceValue, ref blackTerCount, ref whiteTerCount);
                    splitToQueue(x + 1, y, tempNewBoard, ref endQueue, territoryQueue, pieceValue, ref blackTerCount, ref whiteTerCount);
                    splitToQueue(x - 1, y, tempNewBoard, ref endQueue, territoryQueue, pieceValue, ref blackTerCount, ref whiteTerCount);

                    startQueue = (startQueue + 1) % (9 * 9); //Go forward, and wrap
                }

                //Go through queue, expanding it when neccessary
            }

            public static void splitToQueue(int x, int y, int[,] curBoard,
                ref int endQueue, int[,] territoryQueue, int pieceNumber, ref int blackTerCount, ref int whiteTerCount)
            {
                //Out of bounds
                if (x < 0 || y < 0 || x >= 9 || y >= 9)
                    return;

                if (curBoard[x, y] == 0)
                {
                    curBoard[x,y] = -1; //MARK IT, so we don't visit it again!
                    addToQueue(x, y, pieceNumber, ref endQueue, territoryQueue);

                    if (pieceNumber == -1)
                        blackTerCount++;
                    else
                        whiteTerCount++;
                }

            }



            public static void addToQueue(int x, int y, int pieceNumber, ref int endQueue, int[,] territoryQueue)
            {
                territoryQueue[endQueue, 0] = pieceNumber;
                territoryQueue[endQueue, 1] = x;
                territoryQueue[endQueue, 2] = y;

                endQueue = (endQueue + 1) % (9 * 9); //Go forward, and wrap
            }

            public static void removeFromQueue(ref int startQueue, int[,] territoryQueue, out int pieceValue, out int x, out int y)
            {
                pieceValue = territoryQueue[startQueue, 0];
                x = territoryQueue[startQueue, 1];
                y = territoryQueue[startQueue, 2];

                startQueue = (startQueue + 1) % (9 * 9); //Go forward, and wrap
            }


            public override void Play(GTPLibrary.Ent_move move)
            {
                board[move.vertex.xPos, move.vertex.yPos] = move.color.ToString() == "b" ? 1 : 2;
            }

            public override void ResetAndSetSize(int size)
            {
                for (int x = 0; x < 9; x++)
                    for (int y = 0; y < 9; y++)
                        board[x, y] = 0;
            }

            public override string final_score()
            {
                throw new NotImplementedException();
            }

            public override void quit()
            {
                //Nothing to do
            }

            public override string name
            {
                get { return "DotNetGo"; }
            }

            public override string showboard()
            {
                string boardText = "";
                //throw new NotImplementedException();
                for (int x = 0; x < 9; x++)
                {
                    for (int y = 0; y < 9; y++)
                    {
                        boardText += board[x, y] == 0 ? "O" : (board[x, y] == 1 ? "b" : "w");
                    }
                    boardText += "\n";
                }
                return boardText;
            }

            public static string showboard(int[,] board)
            {
                return showboard(board, true);
            }
            public static string showboard(int[,] board, bool showBW)
            {
                string boardText = "";
                //throw new NotImplementedException();
                for (int y = 0; y < 9; y++)
                {
                    for (int x = 0; x < 9; x++)
                    {
                        if (board[x, y] == 0)
                            boardText += "O";
                        else if (board[x, y] == 1 && showBW)
                            boardText += "b";
                        else if (board[x, y] == 2 && showBW)
                            boardText += "w";
                        else if (board[x, y] > -10 && board[x, y] < 10)
                            boardText += Math.Abs(board[x, y]).ToString();
                        else
                            boardText += "?";
                    }
                    boardText += "\n";
                }
                return boardText;
            }
        }

        public partial class GTPInterface
        {
            List<SimpleGoPlayer> goAis = new List<SimpleGoPlayer>();

            public int[,] board = new int[9, 9];
            //0 - empty, negative black, positive white
            int moveNumber = 1;     

            Dictionary<string, double> gamesPlayed = new Dictionary<string, double>();
            Dictionary<string, double> blackWinSum = new Dictionary<string, double>();
            Dictionary<string, double> blackScoreSum = new Dictionary<string, double>();

            public GTPInterface()
            {

                //RecurseSpeedTest();
                //return;


                gamesPlayed.Add("test", 5);

                CreateAI();
                ResetAI();

                foreach (SimpleGoPlayer goAi in goAis)
                    goAi.ResetAndSetSize(9);

                Thread testThread = new Thread(new ThreadStart(TestAI));
                testThread.Start();

                //TestAI();


            }

            void RecurseSpeedTest()
            {
                int boardSampleCount = 100000;
                int tryPlayCount = 75; //We try to play this amount of pieces, but with overlap we may play less

                Random random = new Random();

                int[][,] boardSamples = new int[boardSampleCount][,];
                for (int x = 0; x < boardSampleCount; x++)
                {
                    boardSamples[x] = new int[9, 9];
                    for (int y = 0; y < tryPlayCount; y++)
                    {
                        int xPos = random.Next(9); int yPos = random.Next(9);
                        if (boardSamples[x][xPos, yPos] == 0)
                            boardSamples[x][xPos, yPos] = (y % 2) + 1;
                    }
                }

                //Just make sure they are the same (as it is a deterministic test anyway)
                for (int x = 0; x < boardSampleCount / 10; x++)
                {
                    for (int xPos = 0; xPos < 9; xPos++)
                        for (int yPos = 0; yPos < 9; yPos++)
                        {
                            if (TestDotNetGoPlayer.liberties(xPos, yPos, boardSamples[x]) != TestDotNetGoPlayer.recurseLibertiesBase(xPos, yPos, boardSamples[x]))
                            {
                            }
                        }
                }

                int[] forcedOutput = new int[boardSampleCount * 9 * 9];

                long recurseSpeed = DateTime.Now.Ticks;
                for (int x = 0; x < boardSampleCount; x++)
                    for (int xPos = 0; xPos < 9; xPos++)
                        for (int yPos = 0; yPos < 9; yPos++)
                            forcedOutput[x * 9 * 9 + xPos * 9 + yPos] = TestDotNetGoPlayer.recurseLibertiesBase(xPos, yPos, boardSamples[x]);
                recurseSpeed = DateTime.Now.Ticks - recurseSpeed;

                long nonRecurseSpeed = DateTime.Now.Ticks;
                for (int x = 0; x < boardSampleCount; x++)
                    for (int xPos = 0; xPos < 9; xPos++)
                        for (int yPos = 0; yPos < 9; yPos++)
                            forcedOutput[x * 9 * 9 + xPos * 9 + yPos] = TestDotNetGoPlayer.liberties(xPos, yPos, boardSamples[x]);
                nonRecurseSpeed = DateTime.Now.Ticks - nonRecurseSpeed;
            }

            void TestAI()
            {
                Random random = new Random();

                while (true) //game loop
                {
                    int aiOne = random.Next(goAis.Count);
                    int aiTwo = random.Next(goAis.Count - 1);
                    if (aiTwo >= aiOne)
                        aiTwo++;

                    List<SimpleGoPlayer> curAIs = new List<SimpleGoPlayer>();
                    curAIs.Add(goAis[aiOne]);
                    curAIs.Add(goAis[aiTwo]);

                    RunGame(curAIs);

                    ResetAI();

                } //game while end

            }

            string blackAi, whiteAi;

            bool lastPassed = false;
            void RunGame(List<SimpleGoPlayer> ais)
            {
                foreach (SimpleGoPlayer ai in ais)
                    ai.ResetAndSetSize(9);

                lastPassed = false;

                Output(ais[0].name + "b\t" + ais[1].name + "w\t");

                blackAi = ais[0].name;
                whiteAi = ais[1].name;

                while (true) //Turn loop
                {
                    try
                    {

                        Ent_vertex vertex = ais[0].GetAndPlayMove("b"); //0 is b, 1 is w... just because it has to be this way                    
                        if (!PlayMove(ais, new Ent_move(new Ent_color("b"), vertex), 0))
                        {
                            EndGame(ais[0], ais[1]);
                            break;
                        }

                        vertex = ais[1].GetAndPlayMove("w"); //0 is b, 1 is w... just because it has to be this way                    
                        if (!PlayMove(ais, new Ent_move(new Ent_color("w"), vertex), 1))
                        {
                            EndGame(ais[0], ais[1]);
                            break;
                        }

                    } //main try catch end
                    catch (Exception e)
                    {
                        QuitAIs(ais);

                        CreateAI();
                    }
                }
            }

            //Having the ai generate a move without playing it, and then playing on all ais would be the best
            //but... all ai have to be able to play a move but all don't need to generate one without playing it
            //so this is more likely to work for now.
            bool PlayMove(List<SimpleGoPlayer> ais, Ent_move move, int aiExemption)
            {
                if (move.vertex == null) //resign
                {
                    Output(move.color.ToString() + " resigned");
                    Output("\n");

                    return false;
                }

                if (move.vertex.pass)
                {
                    Output("PASS" + "\t");

                    if (lastPassed)
                        return false;

                    lastPassed = true;
                    return true;
                }

                board[move.vertex.xPos, move.vertex.yPos] = move.color.ToString() == "b" ? moveNumber : -moveNumber;
                moveNumber++;

                Output(move.vertex.ToString() + "\t");

                for (int x = 0; x < ais.Count; x++)
                {
                    if (x != aiExemption)
                    {
                        ais[x].Play(move);
                        lastPassed = false;
                    }
                }

                return true;
            }

            void QuitAIs(List<SimpleGoPlayer> ais)
            {
                for (int x = 0; x < goAis.Count; x++)
                {
                    try
                    {
                        goAis[x].quit();
                    }
                    catch { }
                }
            }

            string curLine = "";
            void Output(string textToOutput)
            {

            }

            void CreateAI()
            {
                QuitAIs(goAis);

                goAis.Clear();

                ProcessWrapper gnuGoAI = new ProcessWrapper(
                   @"C:\Users\quentin\Dropbox\Go AI\AIs\gnugo-3.8\gnugo.exe",
                   "--mode gtp", new ProcessWrapper.lineReceived(ReadOutput));

                ProcessWrapper amigo = new ProcessWrapper(
                    @"C:\Users\quentin\Dropbox\Go AI\AIs\amigogtp-1.7\amigogtp.exe",
                    new ProcessWrapper.lineReceived(ReadOutput));

                ProcessWrapper pachi = new ProcessWrapper(
                    @"C:\Users\quentin\Dropbox\Go AI\AIs\pachi-5.00\pachi.exe",
                    new ProcessWrapper.lineReceived(ReadOutput));

                //goAis.Add(new ProcessBasedPlayer(gnuGoAI));
                //goAis.Add(new ProcessBasedPlayer(pachi));
                goAis.Add(new ProcessBasedPlayer(amigo));
                goAis.Add(new TestDotNetGoPlayer());

                Controller.time_settings(1, 3, 5, pachi);
            }

            void ReadOutput(string one, string two) { }

            void ResetAI()
            {
                foreach (SimpleGoPlayer goAi in goAis)
                    goAi.ResetAndSetSize(9);

                moveNumber = 1;
                for (int x = 0; x < 9; x++)
                    for (int y = 0; y < 9; y++)
                        board[x, y] = 0;
            }

            void EndGame(SimpleGoPlayer blackAI, SimpleGoPlayer whiteAI)
            {
                Output("\nGAME done, final score: ");

                string finalScore = "";

                try
                {
                    finalScore = blackAI.final_score();
                }
                catch
                {
                    try
                    {
                        finalScore = whiteAI.final_score();
                    }
                    catch
                    {
                        Output("neither side can score!");
                    }
                }

                if (finalScore != "")
                {
                    char winner = finalScore.ToLower()[0];
                    double score = Convert.ToDouble(finalScore.Substring(2));

                    string winnerName = winner == 'w' ? whiteAi : blackAi;
                    string loserName = winner == 'b' ? whiteAi : blackAi;

                    Output(winnerName + "\t" + score.ToString());

                    string gameKey = blackAi + " vs " + whiteAi;

                    AddToDict(gamesPlayed, gameKey, 1);
                    AddToDict(blackWinSum, gameKey, 1);
                    AddToDict(blackScoreSum, gameKey, winner == 'b' ? score : -score);
                }

                Output("\n");
            }

            void AddToDict(Dictionary<string, double> dict, string key, double numToAdd)
            {
                if (!dict.ContainsKey(key))
                    dict.Add(key, 0);
                dict[key] += numToAdd;
            }

        }

        public abstract class SimpleGoPlayer
        {
            public abstract Ent_vertex GetAndPlayMove(string color);
            public abstract void Play(Ent_move move);
            public abstract void ResetAndSetSize(int size);
            public abstract string final_score();
            public abstract void quit();
            public abstract string name { get; }
            public abstract string showboard();
        }

        //As oppposed to just a custom pure code player, which is useful for debugging and stuff
        public class ProcessBasedPlayer : SimpleGoPlayer
        {
            public ProcessWrapper proc;
            public ProcessBasedPlayer(ProcessWrapper _proc)
            {
                proc = _proc;
            }

            public override Ent_vertex GetAndPlayMove(string color)
            {
                return Controller.genmove(color, proc);
            }

            public override void Play(Ent_move move)
            {
                Controller.play(move.color.ToString(), move.vertex.xPos, move.vertex.yPos, proc);
            }

            public override void ResetAndSetSize(int size)
            {
                Controller.clear_board(proc);
                Controller.boardsize(size, proc);
            }

            public override string final_score()
            {
                return Controller.final_score(proc);
            }

            public override void quit()
            {
                Controller.quit(proc);
            }

            public override string name
            {
                get
                {
                    return proc.name;
                }
            }

            public override string showboard()
            {
                return Controller.showboard(proc);
            }
        }
    }
}
